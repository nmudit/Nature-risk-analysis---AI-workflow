{
  "name": "Nature Scenario analysis Online Github",
  "nodes": [
    {
      "parameters": {
        "jsCode": "/**\n * Normalize JSON — cover common n8n webhook/body/envelope cases\n *\n * Handles ALL of these inputs:\n *  1) Item is the envelope itself:\n *     { assets:[...], scenario?, question?, run_id?, ... }\n *\n *  2) Assets are inside body:\n *     { body:[...] }  OR  { body:{ assets:[...] } }\n *\n *  3) n8n produced multiple incoming items (rare here, but possible):\n *     $input.all() -> [ {json:{...}}, {json:{...}} ]\n *     - If items are assets: [{asset...},{asset...}] we’ll treat them as the assets list\n *     - If items are envelopes, we’ll merge their assets\n *\n * Also tries to pick scenario/question from:\n * payload -> query -> params -> defaults\n */\n\nconst DEFAULT_SCENARIO = \"Hot House World\";\nconst DEFAULT_QUESTION = \"Summarize key climate and nature-related risks\";\n\n// ---------- helpers ----------\nconst toNumberOrNull = (v) => {\n  if (v === null || v === undefined || v === \"\") return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n};\n\nconst isPlainObject = (v) => v !== null && typeof v === \"object\" && !Array.isArray(v);\n\nconst looksLikeAsset = (o) =>\n  isPlainObject(o) && (\"asset_id\" in o || (\"lat\" in o && \"lon\" in o) || \"value_eur\" in o);\n\nconst normalizeAsset = (asset) => ({\n  ...asset,\n  lat: toNumberOrNull(asset.lat),\n  lon: toNumberOrNull(asset.lon),\n  value_eur: toNumberOrNull(asset.value_eur),\n  data_confidence: toNumberOrNull(asset.data_confidence),\n  last_updated: asset.last_updated ?? null,\n});\n\n// Extract assets from one \"envelope-like\" object\nconst extractAssetsFromObject = (obj) => {\n  if (!isPlainObject(obj)) return null;\n\n  // Preferred\n  if (Array.isArray(obj.assets)) return obj.assets;\n\n  // Common webhook patterns\n  if (Array.isArray(obj.body)) return obj.body;\n  if (isPlainObject(obj.body) && Array.isArray(obj.body.assets)) return obj.body.assets;\n\n  // Sometimes people embed payload\n  if (isPlainObject(obj.payload) && Array.isArray(obj.payload.assets)) return obj.payload.assets;\n\n  return null;\n};\n\nconst pickMeta = (obj) => {\n  // scenario/question/run_id priority: payload fields -> query -> params -> defaults\n  const scenario =\n    obj?.scenario ||\n    obj?.query?.scenario ||\n    obj?.params?.scenario ||\n    DEFAULT_SCENARIO;\n\n  const question =\n    obj?.question ||\n    obj?.query?.question ||\n    obj?.params?.question ||\n    DEFAULT_QUESTION;\n\n  const run_id =\n    obj?.run_id ||\n    obj?.query?.run_id ||\n    obj?.params?.run_id ||\n    `run_${Date.now()}`;\n\n  return { scenario, question, run_id };\n};\n\n// ---------- main ----------\nconst currentItem = $json ?? {};\nconst allItems = ($input?.all?.() ?? []).map((i) => i.json ?? i);\n\n// 1) First try: current item as envelope/body\nlet assets = extractAssetsFromObject(currentItem);\n\n// 2) If not found, try interpreting *all incoming items*\nif (!Array.isArray(assets) || assets.length === 0) {\n  if (allItems.length > 0) {\n    // Case: items are actual assets [{asset...},{asset...}]\n    if (allItems.every(looksLikeAsset)) {\n      assets = allItems;\n    } else {\n      // Case: items are envelopes; merge any found assets\n      const merged = [];\n      for (const it of allItems) {\n        const a = extractAssetsFromObject(it);\n        if (Array.isArray(a) && a.length) merged.push(...a);\n      }\n      assets = merged;\n    }\n  }\n}\n\n// 3) Validate\nif (!Array.isArray(assets) || assets.length === 0) {\n  const debugShape = {\n    current_keys: isPlainObject(currentItem) ? Object.keys(currentItem) : typeof currentItem,\n    current_body_type: isPlainObject(currentItem) ? typeof currentItem.body : undefined,\n    all_items_count: allItems.length,\n  };\n  throw new Error(\n    \"No assets provided. Expected assets[] (preferred) or body[] / body.assets[] or incoming items as assets. Debug: \" +\n      JSON.stringify(debugShape)\n  );\n}\n\n// 4) Metadata: use first sensible source (current item, else first item)\nconst metaSource = isPlainObject(currentItem) ? currentItem : (isPlainObject(allItems[0]) ? allItems[0] : {});\nconst { scenario, question, run_id } = pickMeta(metaSource);\n\n// 5) Normalize assets safely\nconst normalizedAssets = assets.map(normalizeAsset);\n\n// 6) Return one normalized envelope\nreturn {\n  run_metadata: {\n    scenario,\n    question,\n    run_id,\n    received_at: new Date().toISOString(),\n    source: \"webhook\",\n    execution_mode: metaSource.executionMode || \"unknown\",\n  },\n  assets: normalizedAssets,\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3680,
        1264
      ],
      "id": "532bbfb3-040b-4f19-9fe0-12f2350f3ca5",
      "name": "Normalize JSON"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Node 5 — Validate portfolio\n * Input: { run_metadata, assets[] }\n * Output: { run_metadata, valid_assets[], invalid_assets[] }\n */\n\nconst run_metadata = $json.run_metadata || {};\nconst assets = $json.assets || [];\n\nif (!Array.isArray(assets)) {\n  throw new Error(\"Expected $json.assets to be an array.\");\n}\n\nconst toNumber = (v) => {\n  if (v === null || v === undefined || v === \"\") return null;\n  const n = Number(v);\n  return Number.isFinite(n) ? n : null;\n};\n\nconst isBlank = (v) =>\n  v === null || v === undefined || (typeof v === \"string\" && v.trim() === \"\");\n\nconst valid_assets = [];\nconst invalid_assets = [];\n\nfor (let i = 0; i < assets.length; i++) {\n  const a = assets[i] || {};\n\n  const issues = [];\n\n  // --- Asset ID handling ---\n  const raw_asset_id = a.asset_id ?? a.id ?? null;\n\n  // governance rule: asset_id must exist and be non-blank\n  if (isBlank(raw_asset_id)) issues.push(\"asset_id_missing_or_blank\");\n\n  // operational fallback id so downstream merge still works\n  const asset_id = !isBlank(raw_asset_id)\n    ? String(raw_asset_id).trim()\n    : `asset_${i + 1}`;\n\n  // Other fields\n  const asset_type = isBlank(a.asset_type) ? \"unknown\" : String(a.asset_type);\n  const sector = a.sector ?? null;\n  const country = a.country ?? null;\n\n  const lat = toNumber(a.lat);\n  const lon = toNumber(a.lon);\n  const value_eur = toNumber(a.value_eur);\n\n  // Hard validation (geo)\n  if (lat === null) issues.push(\"lat_missing_or_not_numeric\");\n  if (lon === null) issues.push(\"lon_missing_or_not_numeric\");\n  if (lat !== null && (lat < -90 || lat > 90)) issues.push(\"lat_out_of_range\");\n  if (lon !== null && (lon < -180 || lon > 180)) issues.push(\"lon_out_of_range\");\n\n  const normalized = {\n    asset_id,                 // always present (fallback)\n    asset_id_provided: !isBlank(raw_asset_id), // helps reporting\n    asset_type,\n    lat,\n    lon,\n    value_eur,                // can be null (soft)\n    sector,\n    country,\n    source_record: a\n  };\n\n  if (issues.length > 0) {\n    invalid_assets.push({\n      ...normalized,\n      validation_issues: issues\n    });\n  } else {\n    valid_assets.push(normalized);\n  }\n}\n\n// Portfolio-level stats\nconst quality = {\n  total_assets: assets.length,\n  valid_assets: valid_assets.length,\n  invalid_assets: invalid_assets.length,\n  pct_invalid: assets.length ? (invalid_assets.length / assets.length) : 0,\n  pct_missing_value: valid_assets.length\n    ? (valid_assets.filter(x => x.value_eur === null).length / valid_assets.length)\n    : 0,\n  pct_missing_asset_id: assets.length\n    ? (invalid_assets.filter(x => x.validation_issues?.includes(\"asset_id_missing_or_blank\")).length / assets.length)\n    : 0\n};\n\nreturn {\n  run_metadata: {\n    ...run_metadata,\n    quality\n  },\n  valid_assets,\n  invalid_assets\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4352,
        1264
      ],
      "id": "eef8ae56-1f70-413a-a2e3-87e458c52911",
      "name": "Validate Portfolio"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Node 6 — Explode valid_assets into one item per asset\n * Mode: Run once for all items\n */\n\nconst input = items[0].json;\n\nconst run_metadata = input.run_metadata || {};\nconst valid_assets = input.valid_assets || [];\n\nif (!Array.isArray(valid_assets) || valid_assets.length === 0) {\n  throw new Error(\"No valid_assets to process.\");\n}\n\nreturn valid_assets.map(asset => ({\n  json: {\n    run_metadata,\n    asset\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5248,
        1616
      ],
      "id": "32f1415c-78eb-4a92-b0ad-7949507009ae",
      "name": "Explode Valid Assets",
      "retryOnFail": false,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://api.open-meteo.com/v1/forecast",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "latitude",
              "value": "={{ $json.asset.lat }}"
            },
            {
              "name": "longitude",
              "value": "={{ $json.asset.lon }}"
            },
            {
              "name": "forecast_days",
              "value": "7"
            },
            {
              "name": "timezone",
              "value": "UTC"
            },
            {
              "name": "daily",
              "value": "temperature_2m_max,temperature_2m_min,precipitation_sum,wind_gusts_10m_max"
            },
            {
              "name": "hourly",
              "value": "soil_moisture_0_to_1cm"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        6672,
        1728
      ],
      "id": "8474ef70-ff4a-4a7f-a764-8ef29322b813",
      "name": "ClimateData",
      "alwaysOutputData": true,
      "retryOnFail": true,
      "maxTries": 2,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "numberInputs": 6,
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        6896,
        1440
      ],
      "id": "086d0b86-3bf9-4bbc-8689-cef9fc998db9",
      "name": "Merge"
    },
    {
      "parameters": {
        "url": "https://api.gbif.org/v1/occurrence/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "decimalLatitude",
              "value": "={{ $json.asset.lat }}"
            },
            {
              "name": "decimalLongitude",
              "value": "={{ $json.asset.lon }}"
            },
            {
              "name": "hasCoordinate",
              "value": "true"
            },
            {
              "name": "distance",
              "value": "5km"
            },
            {
              "name": "limit",
              "value": "0"
            },
            {
              "name": "facet",
              "value": "iucnRedListCategory"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        6672,
        1456
      ],
      "id": "b20fedeb-d04e-4af1-bfab-98651d83ff32",
      "name": "GBIF-IUCN",
      "retryOnFail": true,
      "maxTries": 2,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://data-gis.unep-wcmc.org/server/rest/services/Bio-geographicalRegions/Resolve_Ecoregions/FeatureServer/0/query",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "geometryType",
              "value": "esriGeometryPoint"
            },
            {
              "name": "f",
              "value": "json"
            },
            {
              "name": "spatialRel",
              "value": "esriSpatialRelIntersects"
            },
            {
              "name": "inSR",
              "value": "4326"
            },
            {
              "name": "outFields",
              "value": "ECO_NAME,BIOME_NAME,REALM"
            },
            {
              "name": "returnGeometry",
              "value": "false"
            },
            {
              "name": "geometry",
              "value": "={{ $json.asset.lon }},{{ $json.asset.lat }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        6672,
        1264
      ],
      "id": "d591e1e0-d5fb-4d16-a930-9cd4713db6a8",
      "name": "Biome",
      "retryOnFail": true,
      "maxTries": 2,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://flood-api.open-meteo.com/v1/flood",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "latitude",
              "value": "={{ $json.asset.lat }}"
            },
            {
              "name": "longitude",
              "value": "={{ $json.asset.lon }}"
            },
            {
              "name": "daily",
              "value": "river_discharge,river_discharge_max,river_discharge_p75"
            },
            {
              "name": "forecast_days",
              "value": "30"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        6672,
        1072
      ],
      "id": "bcb6605f-c8f2-4169-a614-ff765e3d9ab4",
      "name": "Flood",
      "retryOnFail": true,
      "maxTries": 2,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://api.climatetrace.org/v6/assets",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "lat",
              "value": "={{$json.asset.lat}}"
            },
            {
              "name": "lon",
              "value": "={{$json.asset.lon}}"
            },
            {
              "name": "radius_km",
              "value": "25"
            },
            {
              "name": "sector",
              "value": "power,cement,steel,oil-gas,chemicals,waste"
            },
            {
              "name": "gas",
              "value": "co2e_100yr"
            },
            {
              "name": "limit",
              "value": "50"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        6672,
        1920
      ],
      "id": "5dffdfba-3893-4c4e-8fc8-b2952c6315a7",
      "name": "ClimateTRACE",
      "retryOnFail": true,
      "maxTries": 2,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "content": "Data Aggregator\n",
        "height": 1280,
        "width": 784,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        6240,
        896
      ],
      "typeVersion": 1,
      "id": "d89d6b7e-0462-479d-8603-257e94c29baf",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "// Gov: Init run metadata\n// Expects input item like: { run_metadata: {...}, assets: [...] }\n\nconst item = $input.item.json;\nconst rm = item.run_metadata || {};\n\nconst now = new Date().toISOString();\n\n// Minimal governance settings (expand later)\nconst governance = {\n  dq_policy_version: \"v0.1\",\n  data_product: \"climate-nature-portfolio-enrichment\",\n  environment: rm.execution_mode || \"dev\",\n  owners: {\n    data_owner: \"Portfolio Ops\",\n    data_steward: \"ESG Data\",\n    custodian: \"Data Engineering\",\n  },\n  sla: {\n    freshness_days: 30,\n    expected_sources: [\"webhook\", \"climate_api\", \"gbif\", \"ecoregions\"]\n  }\n};\n\nreturn [{\n  json: {\n    ...item,\n    run_metadata: {\n      ...rm,\n      received_at: rm.received_at || now,\n      governance\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3904,
        1264
      ],
      "id": "261d6e24-40cf-4a4b-8f44-532b50743d84",
      "name": "Gov: Init run metadata"
    },
    {
      "parameters": {
        "jsCode": "// Gov: Rules catalog\nconst item = $input.item.json;\n\nconst rules = [\n  {\n    rule_id: \"GEO_001\",\n    dimension: \"Validity\",\n    field: \"lat\",\n    description: \"Latitude must be numeric and between -90 and 90\",\n    severity: \"critical\",\n    weight: 10,\n    owner_role: \"Data Owner\",\n    manual_action: \"Correct coordinates or provide source evidence\",\n    auto_fix: false\n  },\n  {\n    rule_id: \"GEO_002\",\n    dimension: \"Validity\",\n    field: \"lon\",\n    description: \"Longitude must be numeric and between -180 and 180\",\n    severity: \"critical\",\n    weight: 10,\n    owner_role: \"Data Owner\",\n    manual_action: \"Correct coordinates or provide source evidence\",\n    auto_fix: false\n  },\n  {\n    rule_id: \"COM_001\",\n    dimension: \"Completeness\",\n    field: \"asset_id\",\n    description: \"asset_id must be present\",\n    severity: \"critical\",\n    weight: 10,\n    owner_role: \"Data Steward\",\n    manual_action: \"Populate asset_id from source system\",\n    auto_fix: false\n  },\n  {\n    rule_id: \"COM_002\",\n    dimension: \"Completeness\",\n    field: \"value_eur\",\n    description: \"value_eur should be present for exposure-based outputs\",\n    severity: \"major\",\n    weight: 4,\n    owner_role: \"Data Steward\",\n    manual_action: \"Fill value from finance source or estimate method\",\n    auto_fix: false\n  }\n];\n\nreturn [{\n  json: {\n    ...item,\n    governance: {\n      ...(item.governance || {}),\n      rules\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4128,
        1264
      ],
      "id": "46134599-a166-4a6a-b7e9-54643b3082ad",
      "name": "Gov: Rules catalog"
    },
    {
      "parameters": {
        "jsCode": "// Gov: Build issues register\nconst input = $input.item.json;\n\nconst runId = input.run_metadata?.run_id || `run_${Date.now()}`;\nconst observedAt = new Date().toISOString();\n\nconst rules = input.governance?.rules || [];\nconst ruleById = new Map(rules.map(r => [r.rule_id, r]));\n\n// Map your existing Validate Portfolio issue strings to rule_ids.\n// Adjust this mapping to match your current issue strings.\nconst mapIssueToRuleId = (issueStr) => {\n  const m = {\n    asset_id_missing: \"COM_001\",\n    lat_missing: \"GEO_001\",\n    lon_missing: \"GEO_002\",\n    lat_out_of_range: \"GEO_001\",\n    lon_out_of_range: \"GEO_002\",\n    value_eur_missing: \"COM_002\",\n  };\n  return m[issueStr] || null;\n};\n\nconst severityMultiplier = (sev) =>\n  sev === \"critical\" ? 2 : sev === \"major\" ? 1 : 0.5;\n\nconst issues = [];\n\nconst invalidAssets = input.invalid_assets || [];\nfor (const a of invalidAssets) {\n  const asset = a.asset || a; // handle either shape\n  const assetId = asset.asset_id || \"UNKNOWN_ASSET\";\n\n  const issueStrings = a.validation_issues || asset.validation_issues || [];\n  for (const issueStr of issueStrings) {\n    const ruleId = mapIssueToRuleId(issueStr);\n    const rule = ruleId ? ruleById.get(ruleId) : null;\n\n    issues.push({\n      issue_id: `ISS_${runId}_${assetId}_${ruleId || issueStr}`,\n      run_id: runId,\n      asset_id: assetId,\n      rule_id: ruleId,\n      issue_phase: \"input\",\n      raw_issue: issueStr,\n      dimension: rule?.dimension || \"Unknown\",\n      severity: rule?.severity || \"major\",\n      weight: rule?.weight ?? 3,\n      status: \"open\",\n      owner: { role: rule?.owner_role || \"Data Steward\" },\n      recommended_action: rule?.manual_action || \"Review and resolve manually\",\n      evidence: {\n        observed_at: observedAt,\n        source: \"validate_portfolio\",\n      }\n    });\n  }\n}\n\n// Attach issues register to the run\nreturn [{\n  json: {\n    ...input,\n    issues\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4576,
        1264
      ],
      "id": "79b9b69b-c06a-41a8-9b96-24306ec5cd75",
      "name": "Gov: Build issues register"
    },
    {
      "parameters": {
        "jsCode": "// Gov: Score DQ (asset + portfolio)\nconst input = $input.item.json;\n\nconst validAssets = input.valid_assets || [];\nconst invalidAssets = input.invalid_assets || [];\nconst allAssets = [\n  ...validAssets.map(x => x.asset || x),\n  ...invalidAssets.map(x => x.asset || x),\n];\n\nconst issues = input.issues || [];\n\nconst severityMultiplier = (sev) =>\n  sev === \"critical\" ? 2 : sev === \"major\" ? 1 : 0.5;\n\nconst byAsset = new Map();\nfor (const iss of issues) {\n  if (!byAsset.has(iss.asset_id)) byAsset.set(iss.asset_id, []);\n  byAsset.get(iss.asset_id).push(iss);\n}\n\nconst gradeFromScore = (s) => s >= 90 ? \"A\" : s >= 80 ? \"B\" : s >= 70 ? \"C\" : s >= 50 ? \"D\" : \"E\";\n\nconst scoredAssets = allAssets.map(a => {\n  const assetId = a.asset_id || \"UNKNOWN_ASSET\";\n  const assetIssues = byAsset.get(assetId) || [];\n\n  let score = 100;\n  for (const iss of assetIssues) {\n    score -= (iss.weight ?? 3) * severityMultiplier(iss.severity);\n  }\n  score = Math.max(0, Math.min(100, Math.round(score)));\n\n  const grade = gradeFromScore(score);\n\n  // Fit-for-use example flags (simple; refine later)\n  const hasCritical = assetIssues.some(i => i.severity === \"critical\");\n  const fit_for_use = hasCritical ? [] : [\"screening_ok\"];\n\n  return {\n    ...a,\n    dq: {\n      score,\n      grade,\n      issue_count: assetIssues.length,\n      failed_rule_ids: assetIssues.map(i => i.rule_id).filter(Boolean),\n      fit_for_use\n    }\n  };\n});\n\n// Portfolio summary\nconst scores = scoredAssets.map(a => a.dq.score);\nconst avg = scores.length ? Math.round(scores.reduce((p,c)=>p+c,0)/scores.length) : 0;\n\nconst severityCounts = issues.reduce((acc, i) => {\n  acc[i.severity] = (acc[i.severity] || 0) + 1;\n  return acc;\n}, {});\n\nconst dq_summary = {\n  score: avg,\n  grade: gradeFromScore(avg),\n  totals: {\n    assets: scoredAssets.length,\n    issues: issues.length,\n    ...severityCounts\n  }\n};\n\nreturn [{\n  json: {\n    ...input,\n    dq_summary,\n    assets_scored: scoredAssets\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4800,
        1264
      ],
      "id": "a87591ec-9f09-4c5f-8a4c-0d845e03f19a",
      "name": "Gov: Score DQ"
    },
    {
      "parameters": {
        "fieldToSplitOut": "issues",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        5024,
        896
      ],
      "id": "6c9e0407-f30c-4e7f-a410-7604e2171369",
      "name": "Split Issues"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "06cf51fe-73bf-42b7-a714-095e62f32007",
              "leftValue": "=={{ [\"critical\",\"major\"].includes($json.severity) || $json.status === \"open\" }}",
              "rightValue": "critical",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5248,
        896
      ],
      "id": "1e32fe7b-a06a-4e13-b73e-efa43bc209b3",
      "name": "Manual handling"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "dq_issues",
          "cachedResultUrl": ""
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "issue_id": "={{$json.issue_id}}",
            "run_id": "={{$json.run_id}}",
            "asset_id": "={{$json.asset_id}}",
            "rule_id": "={{$json.rule_id || \"\"}}",
            "dimension": "={{$json.dimension}}",
            "severity": "={{$json.severity}}",
            "status": "={{$json.status}}",
            "owner_role": "={{$json.owner?.role || \"\"}}",
            "recommended_action": "={{$json.recommended_action || \"\"}}",
            "observed_at": "={{$json.evidence?.observed_at || \"\"}}",
            "raw_issue": "={{$json.raw_issue || \"\"}}",
            "issue_phase": "{{$json.issue_phase}}"
          },
          "matchingColumns": [
            "issue_id"
          ],
          "schema": [
            {
              "id": "issue_id",
              "displayName": "issue_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "run_id",
              "displayName": "run_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "asset_id",
              "displayName": "asset_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "rule_id",
              "displayName": "rule_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "dimension",
              "displayName": "dimension",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "severity",
              "displayName": "severity",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "owner_role",
              "displayName": "owner_role",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "recommended_action",
              "displayName": "recommended_action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "observed_at",
              "displayName": "observed_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "raw_issue",
              "displayName": "raw_issue",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "issue_phase",
              "displayName": "issue_phase",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5472,
        896
      ],
      "id": "bbe70a83-3234-4407-b419-9d12d1a29806",
      "name": "Append or update row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "3919a785-0545-4bb9-a96a-9d2129816f94",
              "leftValue": "={{ $json.run_metadata.quality.valid_assets }}\n",
              "rightValue": 0,
              "operator": {
                "type": "number",
                "operation": "gt"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        5024,
        1616
      ],
      "id": "8b356bf8-d175-4723-8e09-347d5c1739f4",
      "name": "If1"
    },
    {
      "parameters": {
        "content": "Data Governance for Phase 1\n",
        "height": 864,
        "width": 2000,
        "color": 6
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3632,
        864
      ],
      "typeVersion": 1,
      "id": "7e286b1b-55c3-47eb-9a2a-d2a7ecc16355",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "jsCode": "// Normalize merged tool output into a clean per-asset schema (NO risk scoring)\n// Input: items[] where each item.json is the merged object you pasted\n// Output: one normalized item per input item\n\nfunction safeMin(arr) {\n  return Array.isArray(arr) && arr.length ? Math.min(...arr) : null;\n}\nfunction safeMax(arr) {\n  return Array.isArray(arr) && arr.length ? Math.max(...arr) : null;\n}\nfunction safeAvg(arr) {\n  return Array.isArray(arr) && arr.length\n    ? arr.reduce((a, b) => a + b, 0) / arr.length\n    : null;\n}\nfunction safeSum(arr) {\n  return Array.isArray(arr) && arr.length ? arr.reduce((a, b) => a + b, 0) : null;\n}\nfunction quantile(arr, q) {\n  if (!Array.isArray(arr) || !arr.length) return null;\n  const s = arr.slice().sort((a, b) => a - b);\n  const idx = Math.floor(q * (s.length - 1));\n  return s[idx];\n}\n\nreturn items.map((item) => {\n  const j = item.json;\n\n  // ----- Asset -----\n  const asset = j.asset || {};\n  const src = asset.source_record || {};\n  const assetLat = asset.lat ?? src.lat ?? null;\n  const assetLon = asset.lon ?? src.lon ?? null;\n\n  // ----- BIOME -----\n  const biomeAttrs = j.features?.[0]?.attributes || {};\n  const biome = {\n    eco_name: biomeAttrs.eco_name ?? null,\n    biome_name: biomeAttrs.biome_name ?? null,\n    realm: biomeAttrs.realm ?? null,\n    raw: {\n      geometryType: j.geometryType ?? null,\n      spatialReference: j.spatialReference ?? null,\n      fields: j.fields ?? null,\n      features_count: Array.isArray(j.features) ? j.features.length : null,\n    },\n  };\n\n  // ----- Biodiversity (GBIF + IUCN facet) -----\n  const facet = (j.facets || []).find((f) => f.field === \"IUCN_RED_LIST_CATEGORY\");\n  const countsArr = facet?.counts || [];\n  const iucn_counts = countsArr.reduce((acc, c) => {\n    if (c?.name != null) acc[c.name] = c.count ?? 0;\n    return acc;\n  }, {});\n\n  const biodiversity_gbif_iucn = {\n    gbif_count: j.count ?? null,\n    iucn_red_list_category_counts: iucn_counts,\n    raw: {\n      offset: j.offset ?? null,\n      limit: j.limit ?? null,\n      endOfRecords: j.endOfRecords ?? null,\n      facets: j.facets ?? null,\n      results_count: Array.isArray(j.results) ? j.results.length : null,\n    },\n  };\n\n  // ----- Climate (OpenMeteo) -----\n  const daily = j.daily || {};\n  const hourly = j.hourly || {};\n\n  const tmax = daily.temperature_2m_max || [];\n  const tmin = daily.temperature_2m_min || [];\n  const gust = daily.wind_gusts_10m_max || [];\n  const precip = daily.precipitation_sum || [];\n  const sm = hourly.soil_moisture_0_to_1cm || [];\n\n  const climate = {\n    location: {\n      latitude: j.latitude ?? null,\n      longitude: j.longitude ?? null,\n      elevation_m: j.elevation ?? null,\n      timezone: j.timezone ?? null,\n      timezone_abbreviation: j.timezone_abbreviation ?? null,\n      utc_offset_seconds: j.utc_offset_seconds ?? null,\n      generationtime_ms: j.generationtime_ms ?? null,\n    },\n    units: {\n      daily_units: j.daily_units ?? null,\n      hourly_units: j.hourly_units ?? null,\n    },\n    daily_summary: {\n      days: Array.isArray(daily.time) ? daily.time.length : null,\n      temp_max_avg: safeAvg(tmax),\n      temp_max_max: safeMax(tmax),\n      temp_min_avg: safeAvg(tmin),\n      temp_min_min: safeMin(tmin),\n      wind_gust_max: safeMax(gust),\n      wind_gust_avg: safeAvg(gust),\n      precip_total: safeSum(precip),\n      precip_max_day: safeMax(precip),\n    },\n    soil_moisture_summary: {\n      points: Array.isArray(sm) ? sm.length : null,\n      sm_avg: safeAvg(sm),\n      sm_min: safeMin(sm),\n      sm_max: safeMax(sm),\n      sm_p10: quantile(sm, 0.10),\n      sm_p90: quantile(sm, 0.90),\n      sm_p90_p10: (quantile(sm, 0.90) != null && quantile(sm, 0.10) != null)\n        ? (quantile(sm, 0.90) - quantile(sm, 0.10))\n        : null,\n    },\n    // Keep raw arrays if you want downstream modules to use them.\n    // If payload size becomes a problem, set include_raw=false and remove these.\n    raw: {\n      daily,\n      hourly,\n    },\n  };\n\n  // ----- Quality checks (no scoring; just consistency) -----\n  const climateLat = j.latitude ?? null;\n  const climateLon = j.longitude ?? null;\n  const location_mismatch =\n    assetLat != null && assetLon != null && climateLat != null && climateLon != null\n      ? (Math.abs(assetLat - climateLat) > 0.02 || Math.abs(assetLon - climateLon) > 0.02)\n      : null;\n\n  const quality = {\n    location_mismatch,\n    asset_data_confidence: src.data_confidence ?? null,\n    data_source: src.data_source ?? null,\n    estimation_method: src.estimation_method ?? null,\n  };\n\n  return {\n    json: {\n      asset: {\n        asset_id: asset.asset_id ?? null,\n        asset_type: asset.asset_type ?? null,\n        sector: asset.sector ?? null,\n        country: asset.country ?? null,\n        value_eur: asset.value_eur ?? null,\n        lat: assetLat,\n        lon: assetLon,\n        source_record: src, // keep full richness\n      },\n      run_metadata: j.run_metadata ?? null,\n      biome,\n      biodiversity_gbif_iucn,\n      climate,\n      quality,\n    },\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7168,
        1408
      ],
      "id": "12d3a002-9dd7-41ca-a622-cf4513bc1b5f",
      "name": "Normalize JSON2"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * NF Loop: ENCORE-Aligned Dependency Mapper (v2.0)\n * \n * PURPOSE:\n * Maps assets to their nature dependencies using ENCORE framework classifications.\n * Covers all major sectors with scientifically-grounded ecosystem service dependencies.\n * \n * ENCORE FRAMEWORK REFERENCE:\n * - Source: Natural Capital Finance Alliance & UNEP-WCMC\n * - URL: https://encore.naturalcapital.finance\n * - Dependency ratings: Very High, High, Medium, Low\n * \n * SUPPORTED SECTORS (GICS-aligned where possible):\n * 1. Mining & Extraction (Materials)\n * 2. Energy & Utilities\n * 3. Food, Beverage & Agriculture\n * 4. Tourism & Hospitality\n * 5. Real Estate & Construction\n * 6. Transportation & Logistics\n * 7. Manufacturing (General)\n * 8. Pharmaceuticals & Chemicals\n * 9. Textiles & Apparel\n * 10. Financial Services (indirect)\n * \n * MODE: runOnceForEachItem\n */\n\nconst a = $json.asset || $json;\nconst biome = $json.biome || {};\nconst climate = $json.climate || {};\nconst biodiv = $json.biodiversity_gbif_iucn || {};\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst CONFIG = {\n  // Biome sensitivity modifiers (multiplies dependency strength in sensitive areas)\n  biomeSensitivity: {\n    \"Tropical & Subtropical Moist Broadleaf Forests\": 1.3,\n    \"Tropical & Subtropical Dry Broadleaf Forests\": 1.2,\n    \"Mangroves\": 1.4,\n    \"Flooded Grasslands & Savannas\": 1.2,\n    \"Mediterranean Forests, Woodlands & Scrub\": 1.1,\n    \"Deserts & Xeric Shrublands\": 1.2, // Water dependencies amplified\n    \"Temperate Grasslands, Savannas & Shrublands\": 1.0,\n    \"Temperate Broadleaf & Mixed Forests\": 1.0,\n    \"Boreal Forests/Taiga\": 1.0,\n    \"Tundra\": 1.1,\n    \"default\": 1.0\n  },\n  \n  // Water stress threshold (from climate data) to amplify water dependencies\n  waterStressThreshold: {\n    low: 0.3,    // soil moisture avg above this = low stress\n    high: 0.15   // soil moisture avg below this = high stress\n  },\n  \n  // Species richness proxy (GBIF count) thresholds\n  biodiversityThreshold: {\n    high: 5000,   // High biodiversity area\n    medium: 1000  // Medium biodiversity area\n  }\n};\n\n// ============================================================================\n// ENCORE ECOSYSTEM SERVICES TAXONOMY\n// ============================================================================\n\nconst ECOSYSTEM_SERVICES = {\n  // Provisioning Services\n  SURFACE_WATER: {\n    id: \"surface_water\",\n    name: \"Surface Water\",\n    category: \"Provisioning\",\n    description: \"Provision of freshwater from surface sources (rivers, lakes, wetlands)\"\n  },\n  GROUND_WATER: {\n    id: \"ground_water\", \n    name: \"Ground Water\",\n    category: \"Provisioning\",\n    description: \"Provision of freshwater from underground aquifers\"\n  },\n  BIOMASS_PROVISIONING: {\n    id: \"biomass_provisioning\",\n    name: \"Fibres & Other Materials\",\n    category: \"Provisioning\",\n    description: \"Provision of raw materials from plants and animals\"\n  },\n  GENETIC_MATERIALS: {\n    id: \"genetic_materials\",\n    name: \"Genetic Materials\",\n    category: \"Provisioning\",\n    description: \"Provision of genetic resources for breeding, research, pharmaceuticals\"\n  },\n  \n  // Regulating Services\n  CLIMATE_REGULATION: {\n    id: \"climate_regulation\",\n    name: \"Climate Regulation\",\n    category: \"Regulating\",\n    description: \"Regulation of temperature, precipitation patterns through ecosystems\"\n  },\n  FLOOD_STORM_PROTECTION: {\n    id: \"flood_storm_protection\",\n    name: \"Flood & Storm Protection\",\n    category: \"Regulating\",\n    description: \"Natural buffers against floods, storms, and coastal erosion\"\n  },\n  WATER_QUALITY: {\n    id: \"water_quality\",\n    name: \"Water Quality Regulation\",\n    category: \"Regulating\",\n    description: \"Filtration and purification of water through natural systems\"\n  },\n  SOIL_QUALITY: {\n    id: \"soil_quality\",\n    name: \"Soil Quality Regulation\",\n    category: \"Regulating\",\n    description: \"Maintenance of soil health, structure, and fertility\"\n  },\n  POLLINATION: {\n    id: \"pollination\",\n    name: \"Pollination\",\n    category: \"Regulating\",\n    description: \"Transfer of pollen enabling plant reproduction\"\n  },\n  PEST_CONTROL: {\n    id: \"pest_control\",\n    name: \"Pest & Disease Control\",\n    category: \"Regulating\",\n    description: \"Natural control of pest and disease populations\"\n  },\n  EROSION_CONTROL: {\n    id: \"erosion_control\",\n    name: \"Erosion Control\",\n    category: \"Regulating\",\n    description: \"Prevention of soil loss through vegetation and root systems\"\n  },\n  AIR_QUALITY: {\n    id: \"air_quality\",\n    name: \"Air Quality Regulation\",\n    category: \"Regulating\",\n    description: \"Filtration of air pollutants by vegetation\"\n  },\n  MASS_STABILISATION: {\n    id: \"mass_stabilisation\",\n    name: \"Mass Stabilisation & Erosion Control\",\n    category: \"Regulating\",\n    description: \"Slope stability and prevention of landslides\"\n  },\n  NOISE_REDUCTION: {\n    id: \"noise_reduction\",\n    name: \"Noise Attenuation\",\n    category: \"Regulating\",\n    description: \"Reduction of noise pollution through natural barriers\"\n  },\n  \n  // Cultural/Amenity Services\n  RECREATION: {\n    id: \"recreation\",\n    name: \"Recreation & Tourism\",\n    category: \"Cultural\",\n    description: \"Natural areas supporting recreational and tourism activities\"\n  },\n  AESTHETIC: {\n    id: \"aesthetic\",\n    name: \"Aesthetic Values\",\n    category: \"Cultural\",\n    description: \"Scenic beauty and landscape quality\"\n  }\n};\n\n// ============================================================================\n// SECTOR-SPECIFIC DEPENDENCY MAPPINGS (ENCORE-ALIGNED)\n// ============================================================================\n\n/**\n * Each sector has a list of ecosystem service dependencies with:\n * - service: Reference to ECOSYSTEM_SERVICES\n * - strength: Very High | High | Medium | Low (ENCORE ratings)\n * - type: Operational Critical | Revenue Critical | Operational | Compliance | Reputational\n * - substitutability: Low | Medium | High\n * - time_to_failure: Short (<1yr) | Medium (1-5yr) | Long (>5yr)\n * - rationale: Why this dependency exists\n * - sub_activities: Specific sub-activities with higher/lower dependencies\n */\n\nconst SECTOR_DEPENDENCIES = {\n  \n  // =========================================================================\n  // 1. MINING & EXTRACTION\n  // =========================================================================\n  mining: {\n    keywords: [\"mining\", \"extraction\", \"quarry\", \"mineral\", \"ore\", \"coal\", \"metals\", \"aggregates\"],\n    asset_types: [\"mine\", \"quarry\", \"processing_plant\", \"tailings\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Processing, dust suppression, and cooling require large water volumes. Alternatives (desalination, recycling) are costly.\",\n        sub_activities: {\n          \"ore_processing\": \"Very High\",\n          \"underground_mining\": \"High\",\n          \"open_pit\": \"High\"\n        }\n      },\n      {\n        service: ECOSYSTEM_SERVICES.GROUND_WATER,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Dewatering operations and process water. Aquifer depletion affects long-term viability.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.MASS_STABILISATION,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Slope stability critical for open-pit and tailings dam safety. Vegetation removal increases landslide risk.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"High\",\n        type: \"Compliance\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Discharge permits require minimum water quality. Natural filtration reduces treatment costs.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.EROSION_CONTROL,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Site rehabilitation and tailings stability depend on vegetation cover.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Low\",\n        time_to_failure: \"Long\",\n        rationale: \"Extreme heat affects worker safety and equipment. Microclimate regulation reduces cooling costs.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 2. ENERGY & UTILITIES\n  // =========================================================================\n  energy: {\n    keywords: [\"energy\", \"power\", \"utility\", \"electricity\", \"generation\", \"renewable\", \"solar\", \"wind\", \"hydro\", \"thermal\", \"nuclear\", \"gas\", \"oil\"],\n    asset_types: [\"power_plant\", \"substation\", \"solar_farm\", \"wind_farm\", \"hydroelectric\", \"pipeline\", \"refinery\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Thermal power plants require cooling water. Hydropower depends entirely on river flow.\",\n        sub_activities: {\n          \"thermal_power\": \"Very High\",\n          \"hydroelectric\": \"Very High\",\n          \"nuclear\": \"Very High\",\n          \"solar_pv\": \"Low\",\n          \"wind\": \"Low\"\n        }\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"High\",\n        type: \"Operational\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Extreme temperatures reduce thermal efficiency and increase cooling demand. Affects grid stability.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Coastal and riverside infrastructure vulnerable to flooding. Natural buffers (wetlands, mangroves) reduce exposure.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.MASS_STABILISATION,\n        strength: \"Medium\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Pipeline and transmission infrastructure on slopes require stable ground.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.BIOMASS_PROVISIONING,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Biomass power plants depend on sustainable feedstock supply.\",\n        sub_activities: {\n          \"biomass_power\": \"Very High\",\n          \"other\": \"Low\"\n        }\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 3. FOOD, BEVERAGE & AGRICULTURE\n  // =========================================================================\n  food_agriculture: {\n    keywords: [\"food\", \"beverage\", \"agriculture\", \"farming\", \"crop\", \"livestock\", \"dairy\", \"meat\", \"brewing\", \"processing\", \"agri\"],\n    asset_types: [\"farm\", \"plantation\", \"processing_facility\", \"brewery\", \"dairy\", \"slaughterhouse\", \"greenhouse\", \"orchard\", \"vineyard\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.POLLINATION,\n        strength: \"Very High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"75% of global crops depend on animal pollination. No viable large-scale substitute exists.\",\n        sub_activities: {\n          \"fruit_orchard\": \"Very High\",\n          \"vegetable_farming\": \"Very High\",\n          \"grain_farming\": \"Medium\",\n          \"livestock\": \"Low\"\n        }\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SOIL_QUALITY,\n        strength: \"Very High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Crop yields directly depend on soil fertility, structure, and microbial health.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Irrigation, livestock watering, and food processing require reliable freshwater.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.GROUND_WATER,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Groundwater irrigation critical in water-scarce regions. Aquifer depletion is often irreversible.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.PEST_CONTROL,\n        strength: \"High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Short\",\n        rationale: \"Natural predators control crop pests. Chemical alternatives have cost, resistance, and regulatory implications.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"High\",\n        type: \"Compliance\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Food safety standards require clean water. Contamination can halt production.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Temperature and precipitation patterns directly affect yields, growing seasons, and pest cycles.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.GENETIC_MATERIALS,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Long\",\n        rationale: \"Wild crop relatives provide genetic diversity for breeding disease-resistant varieties.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 4. TOURISM & HOSPITALITY\n  // =========================================================================\n  tourism: {\n    keywords: [\"tourism\", \"hospitality\", \"hotel\", \"resort\", \"travel\", \"leisure\", \"recreation\", \"eco-tourism\", \"safari\", \"cruise\"],\n    asset_types: [\"hotel\", \"resort\", \"lodge\", \"theme_park\", \"marina\", \"ski_resort\", \"national_park_concession\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.RECREATION,\n        strength: \"Very High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Nature-based tourism depends entirely on healthy ecosystems. Degradation directly reduces visitor appeal.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AESTHETIC,\n        strength: \"Very High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Scenic beauty is the core product. Landscape degradation, pollution, or biodiversity loss erodes value.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Short\",\n        rationale: \"Resorts and hotels require water for guests, pools, landscaping. Water scarcity disrupts operations.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Short\",\n        rationale: \"Beach/lake water quality directly affects guest experience and health. Algal blooms, pollution close destinations.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Coastal resorts exposed to storms. Coral reefs and mangroves provide natural protection.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Long\",\n        rationale: \"Ski resorts depend on snowfall. Tropical destinations depend on comfortable temperatures.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AIR_QUALITY,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Air pollution reduces destination attractiveness and guest health.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 5. REAL ESTATE & CONSTRUCTION\n  // =========================================================================\n  real_estate: {\n    keywords: [\"real estate\", \"property\", \"construction\", \"building\", \"development\", \"residential\", \"commercial\", \"office\", \"retail\", \"warehouse\", \"urban\"],\n    asset_types: [\"office_building\", \"residential\", \"commercial\", \"warehouse\", \"shopping_center\", \"mixed_use\", \"industrial_park\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Properties in flood zones face direct damage risk. Natural drainage and wetlands reduce exposure.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"High\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Urban heat island effect increases cooling costs and health risks. Green infrastructure provides cooling.\",\n        sub_activities: {\n          \"urban\": \"High\",\n          \"suburban\": \"Medium\",\n          \"rural\": \"Low\"\n        }\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"High\",\n        time_to_failure: \"Medium\",\n        rationale: \"Buildings require water supply. Municipal systems usually buffer direct dependency.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AIR_QUALITY,\n        strength: \"Medium\",\n        type: \"Compliance\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Indoor air quality linked to outdoor environment. Affects occupant health and building value.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.NOISE_REDUCTION,\n        strength: \"Low\",\n        type: \"Operational\",\n        substitutability: \"High\",\n        time_to_failure: \"Long\",\n        rationale: \"Natural barriers (trees, vegetation) reduce noise pollution. Affects property values.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.MASS_STABILISATION,\n        strength: \"Medium\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Properties on slopes or in areas with soil subsidence risk. Vegetation provides stabilisation.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.EROSION_CONTROL,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Coastal and riverside properties exposed to erosion. Natural buffers reduce structural risk.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 6. TRANSPORTATION & LOGISTICS\n  // =========================================================================\n  transportation: {\n    keywords: [\"transport\", \"transportation\", \"logistics\", \"shipping\", \"freight\", \"rail\", \"road\", \"port\", \"airport\", \"highway\", \"infrastructure\"],\n    asset_types: [\"port\", \"airport\", \"rail_terminal\", \"highway\", \"bridge\", \"tunnel\", \"logistics_hub\", \"distribution_center\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Transport infrastructure highly exposed to flooding. Disruption cascades through supply chains.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.MASS_STABILISATION,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Roads, rail, and pipelines on slopes require stable ground. Landslides cause extended closures.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.EROSION_CONTROL,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Coastal ports and roads exposed to erosion. Embankment vegetation critical for rail/road stability.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"High\",\n        time_to_failure: \"Medium\",\n        rationale: \"Inland waterway transport depends on navigable water levels. Drought affects barge capacity.\",\n        sub_activities: {\n          \"inland_shipping\": \"Very High\",\n          \"port\": \"Medium\",\n          \"road_rail\": \"Low\"\n        }\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Low\",\n        time_to_failure: \"Medium\",\n        rationale: \"Extreme heat affects rail buckling, road surface degradation, and airport operations.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AIR_QUALITY,\n        strength: \"Low\",\n        type: \"Compliance\",\n        substitutability: \"High\",\n        time_to_failure: \"Long\",\n        rationale: \"Airports and ports face emissions regulations. Natural carbon sinks can offset requirements.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 7. MANUFACTURING (General)\n  // =========================================================================\n  manufacturing: {\n    keywords: [\"manufacturing\", \"factory\", \"industrial\", \"production\", \"assembly\", \"automotive\", \"electronics\", \"machinery\", \"steel\", \"cement\"],\n    asset_types: [\"factory\", \"manufacturing_plant\", \"assembly_plant\", \"foundry\", \"steel_mill\", \"cement_plant\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Cooling, processing, and cleaning require significant water volumes.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"High\",\n        type: \"Compliance\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Discharge permits require treatment. Natural filtration reduces costs.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Extreme temperatures affect worker productivity, equipment, and energy costs.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"Medium\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Flooding disrupts production and damages inventory/equipment.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AIR_QUALITY,\n        strength: \"Low\",\n        type: \"Compliance\",\n        substitutability: \"High\",\n        time_to_failure: \"Long\",\n        rationale: \"Emissions regulations tightening. Natural sinks provide compliance buffer.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 8. PHARMACEUTICALS & CHEMICALS\n  // =========================================================================\n  pharmaceuticals: {\n    keywords: [\"pharmaceutical\", \"pharma\", \"chemical\", \"biotech\", \"drug\", \"medicine\", \"laboratory\", \"research\"],\n    asset_types: [\"pharmaceutical_plant\", \"chemical_plant\", \"laboratory\", \"research_facility\", \"biotech_facility\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Ultra-pure water essential for drug manufacturing. Quality requirements are stringent.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Contamination risk to products. Natural source water quality reduces treatment burden.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.GENETIC_MATERIALS,\n        strength: \"High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Long\",\n        rationale: \"Many drugs derived from natural compounds. Biodiversity loss eliminates discovery potential.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Temperature control critical for production and storage. Extreme heat increases cooling costs.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.AIR_QUALITY,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Clean room operations sensitive to air quality. Particulate matter affects production.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 9. TEXTILES & APPAREL\n  // =========================================================================\n  textiles: {\n    keywords: [\"textile\", \"apparel\", \"clothing\", \"fashion\", \"fabric\", \"cotton\", \"garment\", \"leather\", \"wool\"],\n    asset_types: [\"textile_mill\", \"garment_factory\", \"tannery\", \"cotton_gin\", \"dyeing_facility\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n        strength: \"Very High\",\n        type: \"Operational Critical\",\n        substitutability: \"Low\",\n        time_to_failure: \"Short\",\n        rationale: \"Dyeing, washing, and processing are water-intensive. Single garment can require 2,700 liters.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.WATER_QUALITY,\n        strength: \"High\",\n        type: \"Compliance\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Effluent treatment requirements stringent. Dye pollution heavily regulated.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.BIOMASS_PROVISIONING,\n        strength: \"High\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Natural fibres (cotton, wool, silk, leather) depend on agricultural/pastoral ecosystems.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.SOIL_QUALITY,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Medium\",\n        rationale: \"Cotton and other fibre crops require healthy soils. Degradation reduces yields and quality.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.PEST_CONTROL,\n        strength: \"Medium\",\n        type: \"Revenue Critical\",\n        substitutability: \"Medium\",\n        time_to_failure: \"Short\",\n        rationale: \"Cotton particularly vulnerable to pests. Natural pest control reduces chemical dependency.\"\n      }\n    ]\n  },\n\n  // =========================================================================\n  // 10. FINANCIAL SERVICES (Indirect Dependencies)\n  // =========================================================================\n  financial: {\n    keywords: [\"bank\", \"insurance\", \"finance\", \"investment\", \"asset management\", \"lending\"],\n    asset_types: [\"office\", \"data_center\", \"branch\"],\n    dependencies: [\n      {\n        service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n        strength: \"Medium\",\n        type: \"Operational\",\n        substitutability: \"High\",\n        time_to_failure: \"Short\",\n        rationale: \"Physical offices/data centers exposed to flooding. Primary exposure is through portfolio.\"\n      },\n      {\n        service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n        strength: \"Low\",\n        type: \"Operational\",\n        substitutability: \"High\",\n        time_to_failure: \"Long\",\n        rationale: \"Data center cooling costs affected by ambient temperature.\"\n      }\n    ],\n    note: \"Financial sector has primarily INDIRECT dependencies through lending/investment portfolios. Physical asset dependencies are limited.\"\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Normalize string for matching\n */\nfunction normalize(str) {\n  return String(str || \"\").toLowerCase().trim();\n}\n\n/**\n * Check if any keyword matches the sector or asset_type\n */\nfunction matchesSector(sector, assetType, sectorConfig) {\n  const normSector = normalize(sector);\n  const normAssetType = normalize(assetType);\n  \n  // Check keywords\n  for (const kw of sectorConfig.keywords) {\n    if (normSector.includes(kw) || normAssetType.includes(kw)) {\n      return true;\n    }\n  }\n  \n  // Check asset types\n  for (const at of sectorConfig.asset_types) {\n    if (normAssetType.includes(at.replace(/_/g, \" \")) || normAssetType.includes(at)) {\n      return true;\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Get biome sensitivity multiplier\n */\nfunction getBiomeSensitivity(biomeName) {\n  const normBiome = normalize(biomeName);\n  for (const [key, value] of Object.entries(CONFIG.biomeSensitivity)) {\n    if (normBiome.includes(normalize(key))) {\n      return value;\n    }\n  }\n  return CONFIG.biomeSensitivity.default;\n}\n\n/**\n * Determine water stress level from climate data\n */\nfunction getWaterStressLevel(climateData) {\n  const smAvg = climateData?.soil_moisture_summary?.sm_avg;\n  if (smAvg === null || smAvg === undefined) return \"unknown\";\n  if (smAvg >= CONFIG.waterStressThreshold.low) return \"low\";\n  if (smAvg <= CONFIG.waterStressThreshold.high) return \"high\";\n  return \"medium\";\n}\n\n/**\n * Determine biodiversity sensitivity from GBIF data\n */\nfunction getBiodiversitySensitivity(gbifCount) {\n  if (gbifCount === null || gbifCount === undefined) return \"unknown\";\n  if (gbifCount >= CONFIG.biodiversityThreshold.high) return \"high\";\n  if (gbifCount >= CONFIG.biodiversityThreshold.medium) return \"medium\";\n  return \"low\";\n}\n\n/**\n * Adjust dependency strength based on environmental context\n */\nfunction adjustStrength(baseStrength, biomeSensitivity, waterStress, isWaterRelated) {\n  const strengthOrder = [\"Low\", \"Medium\", \"High\", \"Very High\"];\n  let idx = strengthOrder.indexOf(baseStrength);\n  if (idx === -1) idx = 1; // Default to Medium\n  \n  // Biome sensitivity adjustment\n  if (biomeSensitivity > 1.2 && idx < 3) idx += 1;\n  \n  // Water stress adjustment for water-related services\n  if (isWaterRelated && waterStress === \"high\" && idx < 3) idx += 1;\n  \n  return strengthOrder[Math.min(idx, 3)];\n}\n\n/**\n * Map dependency to standardized output format\n */\nfunction mapDependency(dep, sectorName, assetType, biomeSensitivity, waterStress, biodivSensitivity) {\n  const isWaterRelated = [\"surface_water\", \"ground_water\", \"water_quality\"].includes(dep.service.id);\n  \n  // Check for sub-activity specific strength\n  let strength = dep.strength;\n  if (dep.sub_activities) {\n    const normAssetType = normalize(assetType);\n    for (const [subAct, subStrength] of Object.entries(dep.sub_activities)) {\n      if (normAssetType.includes(normalize(subAct))) {\n        strength = subStrength;\n        break;\n      }\n    }\n  }\n  \n  // Adjust for environmental context\n  const adjustedStrength = adjustStrength(strength, biomeSensitivity, waterStress, isWaterRelated);\n  \n  return {\n    ecosystem_service: dep.service.name,\n    ecosystem_service_id: dep.service.id,\n    category: dep.service.category,\n    dependency_strength: adjustedStrength,\n    base_strength: strength,\n    dependency_type: dep.type,\n    substitutability: dep.substitutability,\n    time_to_failure: dep.time_to_failure,\n    rationale: dep.rationale,\n    context_adjustments: {\n      biome_sensitivity: biomeSensitivity,\n      water_stress: waterStress,\n      biodiversity_sensitivity: biodivSensitivity,\n      strength_adjusted: adjustedStrength !== strength\n    },\n    encore_source: \"ENCORE Natural Capital Finance Alliance\",\n    confidence: biodivSensitivity === \"unknown\" ? \"Medium\" : \"High\"\n  };\n}\n\n// ============================================================================\n// MAIN LOGIC\n// ============================================================================\n\nconst sector = a.sector || a.asset?.sector || \"\";\nconst assetType = a.asset_type || a.asset?.asset_type || \"\";\nconst valueEur = Number(a.value_eur ?? a.asset?.value_eur ?? 0) || 0;\n\n// Environmental context\nconst biomeName = biome.biome_name || biome.name || null;\nconst ecoName = biome.eco_name || null;\nconst realm = biome.realm || null;\nconst gbifCount = biodiv.gbif_count ?? null;\n\n// Calculate contextual modifiers\nconst biomeSensitivity = getBiomeSensitivity(biomeName);\nconst waterStress = getWaterStressLevel(climate);\nconst biodivSensitivity = getBiodiversitySensitivity(gbifCount);\n\n// Find matching sectors (can match multiple)\nconst matchedSectors = [];\nconst dependencies = [];\n\nfor (const [sectorKey, sectorConfig] of Object.entries(SECTOR_DEPENDENCIES)) {\n  if (matchesSector(sector, assetType, sectorConfig)) {\n    matchedSectors.push(sectorKey);\n    \n    for (const dep of sectorConfig.dependencies) {\n      // Avoid duplicates (same ecosystem service from multiple sector matches)\n      const alreadyAdded = dependencies.some(d => d.ecosystem_service_id === dep.service.id);\n      if (!alreadyAdded) {\n        dependencies.push(\n          mapDependency(dep, sectorKey, assetType, biomeSensitivity, waterStress, biodivSensitivity)\n        );\n      }\n    }\n  }\n}\n\n// Fallback: If no sector matched, provide generic dependencies\nif (dependencies.length === 0) {\n  matchedSectors.push(\"generic\");\n  \n  const genericDeps = [\n    {\n      service: ECOSYSTEM_SERVICES.SURFACE_WATER,\n      strength: \"Medium\",\n      type: \"Operational\",\n      substitutability: \"Medium\",\n      time_to_failure: \"Medium\",\n      rationale: \"Generic water dependency assumed for unclassified assets.\"\n    },\n    {\n      service: ECOSYSTEM_SERVICES.FLOOD_STORM_PROTECTION,\n      strength: \"Medium\",\n      type: \"Operational\",\n      substitutability: \"Low\",\n      time_to_failure: \"Short\",\n      rationale: \"Physical asset exposure to flooding assumed.\"\n    },\n    {\n      service: ECOSYSTEM_SERVICES.CLIMATE_REGULATION,\n      strength: \"Low\",\n      type: \"Operational\",\n      substitutability: \"High\",\n      time_to_failure: \"Long\",\n      rationale: \"Minimal climate regulation dependency assumed.\"\n    }\n  ];\n  \n  for (const dep of genericDeps) {\n    dependencies.push(\n      mapDependency(dep, \"generic\", assetType, biomeSensitivity, waterStress, biodivSensitivity)\n    );\n  }\n}\n\n// Sort by dependency strength (Very High first)\nconst strengthOrder = { \"Very High\": 0, \"High\": 1, \"Medium\": 2, \"Low\": 3 };\ndependencies.sort((a, b) => \n  (strengthOrder[a.dependency_strength] ?? 4) - (strengthOrder[b.dependency_strength] ?? 4)\n);\n\n// Compute sensitivity flag\nconst sensitivityFlag = (() => {\n  const hasVeryHigh = dependencies.some(d => d.dependency_strength === \"Very High\");\n  const hasHigh = dependencies.some(d => d.dependency_strength === \"High\");\n  const inSensitiveBiome = biomeSensitivity > 1.1;\n  const highBiodiversity = biodivSensitivity === \"high\";\n  const highWaterStress = waterStress === \"high\";\n  \n  if ((hasVeryHigh && inSensitiveBiome) || (hasVeryHigh && highWaterStress)) return \"Very High\";\n  if (hasVeryHigh || (hasHigh && inSensitiveBiome)) return \"High\";\n  if (hasHigh || highBiodiversity) return \"Medium\";\n  return \"Low\";\n})();\n\n// Build output\nreturn {\n  ...$json,\n  nature_dependency: {\n    sector: sector || \"Unknown\",\n    asset_type: assetType || \"Unknown\",\n    value_eur: valueEur,\n    matched_sectors: matchedSectors,\n    \n    // Environmental context used\n    environmental_context: {\n      biome: biomeName,\n      ecoregion: ecoName,\n      realm: realm,\n      biome_sensitivity_factor: biomeSensitivity,\n      water_stress_level: waterStress,\n      biodiversity_sensitivity: biodivSensitivity,\n      gbif_species_count: gbifCount\n    },\n    \n    // Core output\n    dependencies: dependencies,\n    dependency_count: dependencies.length,\n    sensitivity_flag: sensitivityFlag,\n    \n    // Methodology metadata\n    derivation: {\n      method: \"ENCORE-aligned sector mapping with environmental context adjustment\",\n      framework_source: \"Natural Capital Finance Alliance ENCORE Database\",\n      framework_url: \"https://encore.naturalcapital.finance\",\n      version: \"2.0.0\",\n      sectors_covered: Object.keys(SECTOR_DEPENDENCIES).length,\n      ecosystem_services_covered: Object.keys(ECOSYSTEM_SERVICES).length,\n      auto_derived: true,\n      derivation_timestamp: new Date().toISOString()\n    }\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7568,
        1408
      ],
      "id": "edbc3ebd-12b7-4829-8c77-c3eca9ed9de9",
      "name": "NF Loop: Dependency Mapper"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * NF Loop: TNFD Axes + Scenario Pick (v2.0)\n * \n * PURPOSE:\n * Maps asset context to TNFD's 2x2 scenario framework using enriched dependency data.\n * Calculates physical and transition risk axes with transparent, auditable logic.\n * \n * TNFD SCENARIO FRAMEWORK:\n * - X-axis: Ecosystem Service Degradation (physical risk proxy)\n * - Y-axis: Market & Non-Market Alignment (transition risk proxy)\n * \n * SCENARIOS (TNFD 2x2):\n * ┌─────────────────────┬─────────────────────┐\n * │  Go fast or go home │  Ahead of the game  │  High Alignment\n * │  (Severe + Aligned) │  (Moderate + Aligned│\n * ├─────────────────────┼─────────────────────┤\n * │  Sand in the gears  │  Back of the list   │  Low Alignment\n * │  (Severe + Conflict)│  (Moderate + Lagged)│\n * └─────────────────────┴─────────────────────┘\n *       Severe Degradation    Moderate Degradation\n * \n * INPUTS EXPECTED:\n * - $json.nature_dependency (from improved Dependency Mapper v2.0)\n * - $json.asset (asset metadata)\n * - $json.biome (biome context)\n * - $json.climate (climate data)\n * - $json.biodiversity_gbif_iucn (biodiversity context)\n * \n * MODE: runOnceForEachItem\n */\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst CONFIG = {\n  // Default time horizon (can be overridden by input)\n  defaultHorizonYear: 2030,\n  \n  // Physical axis scoring weights\n  physical: {\n    // Dependency strength contributions to physical risk\n    dependencyStrengthScores: {\n      \"Very High\": 0.95,\n      \"High\": 0.75,\n      \"Medium\": 0.50,\n      \"Low\": 0.25\n    },\n    \n    // Substitutability affects resilience (lower = higher risk)\n    substitutabilityScores: {\n      \"Low\": 0.90,\n      \"Medium\": 0.60,\n      \"High\": 0.30\n    },\n    \n    // Time to failure affects urgency (shorter = higher risk)\n    timeToFailureScores: {\n      \"Short\": 0.90,\n      \"Medium\": 0.60,\n      \"Long\": 0.30\n    },\n    \n    // Environmental context multipliers\n    biomeMultipliers: {\n      \"Very High\": 1.25,  // Mangroves, tropical forests\n      \"High\": 1.15,\n      \"Medium\": 1.05,\n      \"Low\": 1.00\n    },\n    \n    // Water stress impact\n    waterStressMultipliers: {\n      \"high\": 1.20,\n      \"medium\": 1.05,\n      \"low\": 1.00,\n      \"unknown\": 1.00\n    },\n    \n    // Biodiversity sensitivity impact\n    biodiversityMultipliers: {\n      \"high\": 1.15,\n      \"medium\": 1.05,\n      \"low\": 1.00,\n      \"unknown\": 1.00\n    },\n    \n    // Category weights (which types of dependencies matter most for physical risk)\n    categoryWeights: {\n      \"Provisioning\": 1.2,   // Direct resource dependencies\n      \"Regulating\": 1.0,     // Ecosystem regulation services\n      \"Cultural\": 0.6        // Less direct physical impact\n    }\n  },\n  \n  // Transition axis scoring (policy/market alignment)\n  transition: {\n    // Country-level policy alignment scores (TNFD/biodiversity policy readiness)\n    // Scale: 0 = no alignment, 1 = full alignment\n    // Sources: CBD, EU Biodiversity Strategy, national NBSAPs\n    countryScores: {\n      // EU leaders (EU Biodiversity Strategy 2030, strong CSRD/SFDR)\n      \"NL\": { score: 0.80, source: \"Dutch National Biodiversity Strategy, EU Taxonomy alignment\" },\n      \"DE\": { score: 0.78, source: \"German NBS, strong corporate disclosure requirements\" },\n      \"FR\": { score: 0.82, source: \"French Biodiversity Law (Article 29), EU leader\" },\n      \"SE\": { score: 0.80, source: \"Swedish EPA biodiversity targets\" },\n      \"DK\": { score: 0.78, source: \"Danish Biodiversity Strategy 2030\" },\n      \"FI\": { score: 0.76, source: \"Finnish Biodiversity Action Plan\" },\n      \"AT\": { score: 0.74, source: \"Austrian Biodiversity Strategy 2030+\" },\n      \"BE\": { score: 0.72, source: \"Belgian National Biodiversity Strategy\" },\n      \"LU\": { score: 0.75, source: \"Luxembourg green finance hub\" },\n      \"IE\": { score: 0.70, source: \"Ireland National Biodiversity Action Plan\" },\n      \n      // Other EU (moderate alignment)\n      \"ES\": { score: 0.68, source: \"Spanish Strategic Plan for Natural Heritage\" },\n      \"IT\": { score: 0.65, source: \"Italian National Biodiversity Strategy\" },\n      \"PT\": { score: 0.66, source: \"Portuguese Nature Conservation Strategy\" },\n      \"PL\": { score: 0.55, source: \"Polish biodiversity targets lag EU average\" },\n      \"CZ\": { score: 0.58, source: \"Czech State Nature Conservation Programme\" },\n      \"GR\": { score: 0.60, source: \"Greek National Biodiversity Strategy\" },\n      \n      // UK (post-Brexit, Environment Act)\n      \"GB\": { score: 0.72, source: \"UK Environment Act 2021, TNFD early adopter\" },\n      \"UK\": { score: 0.72, source: \"UK Environment Act 2021, TNFD early adopter\" },\n      \n      // North America\n      \"US\": { score: 0.50, source: \"Fragmented federal policy, state variation high\" },\n      \"CA\": { score: 0.62, source: \"Canadian Biodiversity Strategy, provincial variation\" },\n      \n      // Asia-Pacific developed\n      \"JP\": { score: 0.65, source: \"Japan TNFD consortium leader, corporate uptake\" },\n      \"AU\": { score: 0.58, source: \"Australian Nature Positive Plan, implementation lagging\" },\n      \"NZ\": { score: 0.68, source: \"NZ Biodiversity Strategy, strong Māori integration\" },\n      \"SG\": { score: 0.60, source: \"Singapore Green Plan 2030\" },\n      \"KR\": { score: 0.55, source: \"Korean biodiversity framework developing\" },\n      \n      // Emerging markets (variable)\n      \"CN\": { score: 0.52, source: \"China CBD host 2022, implementation variable\" },\n      \"IN\": { score: 0.45, source: \"India National Biodiversity Action Plan, enforcement gaps\" },\n      \"BR\": { score: 0.40, source: \"Brazil deforestation policy instability\" },\n      \"ID\": { score: 0.42, source: \"Indonesia forest moratorium, palm oil challenges\" },\n      \"MY\": { score: 0.45, source: \"Malaysian biodiversity policy, commodity pressure\" },\n      \"TH\": { score: 0.48, source: \"Thai Biodiversity-based Economy Strategy\" },\n      \"VN\": { score: 0.44, source: \"Vietnam National Biodiversity Strategy\" },\n      \"PH\": { score: 0.46, source: \"Philippine Biodiversity Strategy and Action Plan\" },\n      \n      // Africa\n      \"ZA\": { score: 0.50, source: \"South African National Biodiversity Framework\" },\n      \"KE\": { score: 0.48, source: \"Kenya National Biodiversity Strategy\" },\n      \"NG\": { score: 0.38, source: \"Nigeria biodiversity governance challenges\" },\n      \n      // Latin America\n      \"MX\": { score: 0.52, source: \"Mexico National Biodiversity Strategy\" },\n      \"CL\": { score: 0.55, source: \"Chile National Biodiversity Strategy\" },\n      \"CO\": { score: 0.50, source: \"Colombia biodiversity leader, implementation gaps\" },\n      \"PE\": { score: 0.48, source: \"Peru National Biodiversity Strategy\" },\n      \"AR\": { score: 0.42, source: \"Argentina biodiversity policy fragmented\" },\n      \n      // Middle East\n      \"AE\": { score: 0.45, source: \"UAE National Biodiversity Strategy\" },\n      \"SA\": { score: 0.40, source: \"Saudi Vision 2030, biodiversity nascent\" },\n      \n      // Default for unlisted countries\n      \"default\": { score: 0.50, source: \"Default assumption for unlisted jurisdiction\" }\n    },\n    \n    // Sector-level transition pressure (regulatory/market pressure on nature)\n    sectorPressure: {\n      // High pressure sectors (active regulation, investor scrutiny)\n      \"mining\": { pressure: 0.85, source: \"Mining sector faces biodiversity offset requirements, water permits\" },\n      \"food_agriculture\": { pressure: 0.80, source: \"EU deforestation regulation, EUDR, farm-to-fork\" },\n      \"energy\": { pressure: 0.75, source: \"Energy transition, biodiversity net gain requirements\" },\n      \"textiles\": { pressure: 0.70, source: \"EU textile strategy, supply chain due diligence\" },\n      \"pharmaceuticals\": { pressure: 0.65, source: \"Nagoya Protocol, ABS regulations\" },\n      \n      // Medium pressure\n      \"tourism\": { pressure: 0.60, source: \"Eco-certification, destination sustainability pressure\" },\n      \"real_estate\": { pressure: 0.55, source: \"Biodiversity net gain (UK), green building standards\" },\n      \"manufacturing\": { pressure: 0.50, source: \"General environmental compliance, variable by subsector\" },\n      \"transportation\": { pressure: 0.50, source: \"Infrastructure EIAs, habitat fragmentation concerns\" },\n      \n      // Lower direct pressure\n      \"financial\": { pressure: 0.45, source: \"TNFD adoption, portfolio screening emerging\" },\n      \n      // Default\n      \"generic\": { pressure: 0.50, source: \"Default sector pressure assumption\" }\n    },\n    \n    // Dependency type affects transition exposure\n    dependencyTypeScores: {\n      \"Revenue Critical\": 0.90,      // Direct revenue impact = high transition risk\n      \"Operational Critical\": 0.80,  // Operations disruption\n      \"Compliance\": 0.70,            // Regulatory pressure\n      \"Operational\": 0.50,           // General operations\n      \"Reputational\": 0.40           // Softer pressure\n    }\n  },\n  \n  // Scenario thresholds\n  scenarios: {\n    // Physical axis threshold (above = severe, below = moderate)\n    physicalThreshold: 0.60,\n    // Transition axis threshold (above = aligned, below = conflicting)\n    transitionThreshold: 0.55\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Safe get nested value\n */\nfunction safeGet(obj, path, defaultValue = null) {\n  try {\n    return path.split('.').reduce((acc, part) => acc?.[part], obj) ?? defaultValue;\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Normalize string for matching\n */\nfunction normalize(str) {\n  return String(str || \"\").toLowerCase().trim();\n}\n\n/**\n * Calculate weighted average\n */\nfunction weightedAverage(items, valueKey, weightKey) {\n  if (!items || items.length === 0) return 0;\n  \n  let totalWeight = 0;\n  let weightedSum = 0;\n  \n  for (const item of items) {\n    const value = item[valueKey] ?? 0;\n    const weight = item[weightKey] ?? 1;\n    weightedSum += value * weight;\n    totalWeight += weight;\n  }\n  \n  return totalWeight > 0 ? weightedSum / totalWeight : 0;\n}\n\n/**\n * Clamp value between 0 and 1\n */\nfunction clamp01(value) {\n  return Math.max(0, Math.min(1, value));\n}\n\n/**\n * Get biome sensitivity category from factor\n */\nfunction getBiomeSensitivityCategory(factor) {\n  if (factor >= 1.3) return \"Very High\";\n  if (factor >= 1.15) return \"High\";\n  if (factor >= 1.05) return \"Medium\";\n  return \"Low\";\n}\n\n/**\n * Calculate physical axis score from dependencies\n */\nfunction calculatePhysicalAxis(dependencies, envContext) {\n  if (!dependencies || dependencies.length === 0) {\n    return { score: 0.5, components: [], method: \"default_no_dependencies\" };\n  }\n  \n  const components = [];\n  \n  // Score each dependency\n  for (const dep of dependencies) {\n    // Base score from dependency strength\n    const strengthScore = CONFIG.physical.dependencyStrengthScores[dep.dependency_strength] ?? 0.5;\n    \n    // Substitutability modifier (low substitutability = higher risk)\n    const subScore = CONFIG.physical.substitutabilityScores[dep.substitutability] ?? 0.6;\n    \n    // Time to failure modifier (short = higher urgency)\n    const ttfScore = CONFIG.physical.timeToFailureScores[dep.time_to_failure] ?? 0.6;\n    \n    // Category weight\n    const categoryWeight = CONFIG.physical.categoryWeights[dep.category] ?? 1.0;\n    \n    // Combined dependency score\n    const depScore = (strengthScore * 0.50) + (subScore * 0.25) + (ttfScore * 0.25);\n    \n    components.push({\n      ecosystem_service: dep.ecosystem_service,\n      strength_score: strengthScore,\n      substitutability_score: subScore,\n      time_to_failure_score: ttfScore,\n      category_weight: categoryWeight,\n      combined_score: depScore,\n      weighted_score: depScore * categoryWeight\n    });\n  }\n  \n  // Calculate base physical score (weighted by category)\n  const baseScore = weightedAverage(components, 'combined_score', 'category_weight');\n  \n  // Apply environmental context multipliers\n  const biomeCat = getBiomeSensitivityCategory(envContext.biome_sensitivity_factor || 1.0);\n  const biomeMultiplier = CONFIG.physical.biomeMultipliers[biomeCat] ?? 1.0;\n  const waterMultiplier = CONFIG.physical.waterStressMultipliers[envContext.water_stress_level] ?? 1.0;\n  const biodivMultiplier = CONFIG.physical.biodiversityMultipliers[envContext.biodiversity_sensitivity] ?? 1.0;\n  \n  // Combined multiplier (geometric mean to avoid explosion)\n  const combinedMultiplier = Math.pow(biomeMultiplier * waterMultiplier * biodivMultiplier, 1/3);\n  \n  // Final physical axis score\n  const finalScore = clamp01(baseScore * combinedMultiplier);\n  \n  return {\n    score: finalScore,\n    base_score: baseScore,\n    multipliers: {\n      biome: { category: biomeCat, value: biomeMultiplier },\n      water_stress: { level: envContext.water_stress_level, value: waterMultiplier },\n      biodiversity: { level: envContext.biodiversity_sensitivity, value: biodivMultiplier },\n      combined: combinedMultiplier\n    },\n    components: components.slice(0, 5), // Top 5 for explainability\n    method: \"dependency_weighted_with_environmental_context\"\n  };\n}\n\n/**\n * Calculate transition axis score\n */\nfunction calculateTransitionAxis(country, matchedSectors, dependencies) {\n  // Country policy alignment\n  const countryCode = String(country || \"\").toUpperCase().substring(0, 2);\n  const countryData = CONFIG.transition.countryScores[countryCode] || CONFIG.transition.countryScores[\"default\"];\n  const countryScore = countryData.score;\n  \n  // Sector pressure (average across matched sectors)\n  let sectorPressure = 0.5;\n  let sectorSources = [];\n  \n  if (matchedSectors && matchedSectors.length > 0) {\n    const sectorScores = matchedSectors.map(s => {\n      const data = CONFIG.transition.sectorPressure[s] || CONFIG.transition.sectorPressure[\"generic\"];\n      sectorSources.push({ sector: s, pressure: data.pressure, source: data.source });\n      return data.pressure;\n    });\n    sectorPressure = sectorScores.reduce((a, b) => a + b, 0) / sectorScores.length;\n  }\n  \n  // Dependency type exposure (how much regulatory pressure based on dependency types)\n  let depTypeExposure = 0.5;\n  if (dependencies && dependencies.length > 0) {\n    const depTypeScores = dependencies.map(d => {\n      return CONFIG.transition.dependencyTypeScores[d.dependency_type] ?? 0.5;\n    });\n    depTypeExposure = depTypeScores.reduce((a, b) => a + b, 0) / depTypeScores.length;\n  }\n  \n  // Combine: country alignment moderates, sector pressure and dep exposure increase transition risk\n  // Higher country alignment + higher sector pressure = higher transition score (more aligned, faster action)\n  // The formula: aligned countries with high-pressure sectors have HIGH transition scores\n  const transitionScore = clamp01(\n    (countryScore * 0.45) +           // Country policy alignment\n    (sectorPressure * 0.35) +          // Sector-specific pressure\n    (depTypeExposure * 0.20)           // Dependency type exposure\n  );\n  \n  return {\n    score: transitionScore,\n    components: {\n      country: {\n        code: countryCode,\n        score: countryScore,\n        source: countryData.source,\n        weight: 0.45\n      },\n      sector: {\n        matched_sectors: matchedSectors || [],\n        pressure: sectorPressure,\n        details: sectorSources.slice(0, 3),\n        weight: 0.35\n      },\n      dependency_type_exposure: {\n        score: depTypeExposure,\n        weight: 0.20\n      }\n    },\n    method: \"country_sector_dependency_weighted\"\n  };\n}\n\n/**\n * Determine scenario based on axes\n */\nfunction determineScenario(physicalScore, transitionScore) {\n  const severe = physicalScore >= CONFIG.scenarios.physicalThreshold;\n  const aligned = transitionScore >= CONFIG.scenarios.transitionThreshold;\n  \n  let scenario;\n  if (!severe && aligned) {\n    scenario = {\n      id: 1,\n      name: \"Ahead of the game\",\n      quadrant: \"moderate_aligned\",\n      description: \"Moderate ecosystem degradation with coherent policy/market alignment. Earlier action enables managed transition.\",\n      risk_posture: \"Proactive adaptation, competitive advantage from early movers\",\n      typical_response: \"Voluntary disclosure, nature-positive commitments, green finance access\"\n    };\n  } else if (severe && aligned) {\n    scenario = {\n      id: 2,\n      name: \"Go fast or go home\",\n      quadrant: \"severe_aligned\",\n      description: \"Severe ecosystem degradation but strong alignment of market/non-market forces. Rapid, coordinated transition required.\",\n      risk_posture: \"Urgent transformation, high capital reallocation\",\n      typical_response: \"Accelerated decarbonization, supply chain restructuring, stranded asset risk\"\n    };\n  } else if (severe && !aligned) {\n    scenario = {\n      id: 3,\n      name: \"Sand in the gears\",\n      quadrant: \"severe_conflicting\",\n      description: \"Severe ecosystem degradation with conflicting/fragmented policy signals. Disorderly transition, operational disruption.\",\n      risk_posture: \"High uncertainty, reactive crisis management\",\n      typical_response: \"Regulatory arbitrage risk, supply chain disruption, insurance challenges\"\n    };\n  } else {\n    scenario = {\n      id: 4,\n      name: \"Back of the list\",\n      quadrant: \"moderate_conflicting\",\n      description: \"Moderate degradation initially with lagged response. Weak incentives lead to gradual risk accumulation.\",\n      risk_posture: \"Complacency risk, sudden repricing possible\",\n      typical_response: \"Business as usual with emerging tail risks, underinvestment in resilience\"\n    };\n  }\n  \n  return {\n    ...scenario,\n    axes_interpretation: {\n      physical: severe ? \"Severe ecosystem service degradation\" : \"Moderate ecosystem service degradation\",\n      transition: aligned ? \"High market/non-market alignment\" : \"Low/conflicting market/non-market alignment\"\n    },\n    thresholds_used: {\n      physical: CONFIG.scenarios.physicalThreshold,\n      transition: CONFIG.scenarios.transitionThreshold\n    }\n  };\n}\n\n// ============================================================================\n// MAIN LOGIC\n// ============================================================================\n\nconst nd = $json.nature_dependency || {};\nconst asset = $json.asset || {};\nconst dependencies = nd.dependencies || [];\nconst envContext = nd.environmental_context || {};\nconst matchedSectors = nd.matched_sectors || [];\n\n// Get country (try multiple sources)\nconst country = asset.country || \n                safeGet($json, 'asset.source_record.country') ||\n                safeGet($json, 'biome.country') ||\n                null;\n\n// Get or set horizon year\nconst horizonYear = $json.horizon_year || \n                    safeGet($json, 'run_metadata.horizon_year') ||\n                    CONFIG.defaultHorizonYear;\n\n// Calculate axes\nconst physicalCalc = calculatePhysicalAxis(dependencies, envContext);\nconst transitionCalc = calculateTransitionAxis(country, matchedSectors, dependencies);\n\n// Determine scenario\nconst scenario = determineScenario(physicalCalc.score, transitionCalc.score);\n\n// Build comprehensive output\nconst tnfd_scenario_frame = {\n  // Core axes (backward compatible)\n  horizon_year: horizonYear,\n  axes: {\n    ecosystem_service_degradation: Number(physicalCalc.score.toFixed(4)),\n    market_nonmarket_alignment: Number(transitionCalc.score.toFixed(4))\n  },\n  \n  // Scenario selection (backward compatible)\n  scenario: {\n    scenario_id: scenario.id,\n    scenario_name: scenario.name\n  },\n  \n  // Enhanced: Full scenario context\n  scenario_detail: {\n    ...scenario,\n    confidence: dependencies.length >= 3 ? \"High\" : dependencies.length >= 1 ? \"Medium\" : \"Low\"\n  },\n  \n  // Enhanced: Physical axis breakdown\n  physical_axis_detail: {\n    score: physicalCalc.score,\n    interpretation: physicalCalc.score >= 0.7 ? \"Very High Risk\" :\n                    physicalCalc.score >= 0.5 ? \"High Risk\" :\n                    physicalCalc.score >= 0.3 ? \"Moderate Risk\" : \"Low Risk\",\n    base_score: physicalCalc.base_score,\n    environmental_multipliers: physicalCalc.multipliers,\n    top_contributing_dependencies: physicalCalc.components,\n    method: physicalCalc.method\n  },\n  \n  // Enhanced: Transition axis breakdown\n  transition_axis_detail: {\n    score: transitionCalc.score,\n    interpretation: transitionCalc.score >= 0.7 ? \"High Alignment\" :\n                    transitionCalc.score >= 0.5 ? \"Moderate Alignment\" :\n                    transitionCalc.score >= 0.3 ? \"Low Alignment\" : \"Very Low Alignment\",\n    components: transitionCalc.components,\n    method: transitionCalc.method\n  },\n  \n  // Methodology metadata\n  methodology: {\n    framework: \"TNFD Scenario Analysis Guidance v1.0\",\n    framework_url: \"https://tnfd.global/recommendations-of-the-tnfd/additional-guidance/scenario-analysis/\",\n    axes_basis: \"Physical risk from ENCORE dependency mapping; Transition risk from policy alignment + sector pressure\",\n    version: \"2.0.0\",\n    calculated_at: new Date().toISOString()\n  },\n  \n  // Backward compatibility\n  method_note: `Scenario \"${scenario.name}\" selected based on physical axis (${physicalCalc.score.toFixed(2)}) and transition axis (${transitionCalc.score.toFixed(2)}). Physical threshold: ${CONFIG.scenarios.physicalThreshold}, Transition threshold: ${CONFIG.scenarios.transitionThreshold}.`\n};\n\nreturn {\n  ...$json,\n  tnfd_scenario_frame\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7792,
        1408
      ],
      "id": "699076e7-d0d2-439a-a19f-73100de473b7",
      "name": "NF Loop: TNFD Axes + Scenario Pick"
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "Retrieve necessary chunks of text depending on input",
        "pineconeIndex": {
          "__rl": true,
          "value": "natureriskscenarios",
          "mode": "list",
          "cachedResultName": "natureriskscenarios"
        },
        "topK": 15,
        "options": {
          "pineconeNamespace": "naturerisk_scenarios"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePinecone",
      "typeVersion": 1.3,
      "position": [
        9264,
        1552
      ],
      "id": "0dfef412-677c-4167-8123-fa038f08bf5a",
      "name": "Pinecone Vector Store1",
      "credentials": {
        "pineconeApi": {
          "id": "EIq4WKtDUI0Xg9NK",
          "name": "PineconeApi account 2"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-large",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        9344,
        1760
      ],
      "id": "db00de58-22a9-4c0b-8d86-ebd3b595280c",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 4000,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        9136,
        1552
      ],
      "id": "ebfbd57e-d672-47b1-a573-793d8ed8fd53",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * NF Loop: RAG Query Builder (v2.0)\n * \n * PURPOSE:\n * Constructs optimized, focused queries for vector retrieval from TNFD/nature risk knowledge base.\n * Replaces single kitchen-sink query with multiple targeted queries for better retrieval quality.\n * \n * KEY IMPROVEMENTS:\n * 1. Multiple focused queries instead of one overloaded query\n * 2. Query templates aligned to TNFD LEAP framework\n * 3. Service-specific retrieval hints based on ENCORE taxonomy\n * 4. Scenario-narrative retrieval for context grounding\n * 5. Sector-specific pathway retrieval\n * \n * INPUTS EXPECTED:\n * - $json.asset (asset metadata)\n * - $json.nature_dependency (from Dependency Mapper v2.0)\n * - $json.tnfd_scenario_frame (from TNFD Axes + Scenario Pick v2.0)\n * - $json.biome (biome context)\n * - $json.biodiversity_gbif_iucn (biodiversity context)\n * - $json.climate (climate data)\n * \n * OUTPUT:\n * - rag_queries: Array of focused query objects\n * - rag_query: Combined query string (backward compatible)\n * - rag_filters: Metadata filters for Pinecone\n * - rag_strategy: Explanation of query strategy\n * \n * MODE: runOnceForEachItem\n */\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst CONFIG = {\n  // Maximum queries to generate (balance coverage vs. token cost)\n  maxQueries: 5,\n  \n  // Top-K per query type\n  topK: {\n    framework: 4,      // TNFD framework/methodology chunks\n    scenario: 3,       // Scenario narrative chunks\n    service: 3,        // Per ecosystem service\n    sector: 3,         // Sector-specific pathways\n    financial: 2       // Financial transmission channels\n  },\n  \n  // Query priorities (higher = more important, selected first if query budget limited)\n  queryPriority: {\n    framework: 1,\n    service_critical: 2,\n    scenario: 3,\n    sector: 4,\n    service_secondary: 5,\n    financial: 6\n  }\n};\n\n// ============================================================================\n// TNFD FRAMEWORK QUERY TEMPLATES\n// ============================================================================\n\nconst FRAMEWORK_QUERIES = {\n  leap_locate: {\n    query: \"TNFD LEAP Locate phase interface with nature priority locations biodiversity importance\",\n    intent: \"Retrieve guidance on identifying nature interface points\",\n    doc_types: [\"guidance\", \"methodology\"]\n  },\n  leap_evaluate: {\n    query: \"TNFD LEAP Evaluate dependencies impacts ecosystem services materiality assessment\",\n    intent: \"Retrieve dependency/impact evaluation methodology\",\n    doc_types: [\"guidance\", \"methodology\"]\n  },\n  leap_assess: {\n    query: \"TNFD LEAP Assess nature-related risks opportunities scenario analysis financial materiality\",\n    intent: \"Retrieve risk assessment and scenario guidance\",\n    doc_types: [\"guidance\", \"scenario\"]\n  },\n  leap_prepare: {\n    query: \"TNFD LEAP Prepare disclosure metrics targets strategy response\",\n    intent: \"Retrieve disclosure and response guidance\",\n    doc_types: [\"guidance\", \"disclosure\"]\n  }\n};\n\n// ============================================================================\n// SCENARIO NARRATIVE TEMPLATES\n// ============================================================================\n\nconst SCENARIO_QUERIES = {\n  \"Ahead of the game\": {\n    query: \"nature scenario moderate degradation high alignment proactive transition early action managed adaptation policy coherence\",\n    keywords: [\"proactive\", \"early movers\", \"managed transition\", \"policy alignment\", \"nature positive\"],\n    risk_narrative: \"Orderly transition with market rewards for leaders\"\n  },\n  \"Go fast or go home\": {\n    query: \"nature scenario severe degradation rapid transition tipping points urgent action ecosystem collapse coordinated response\",\n    keywords: [\"rapid action\", \"tipping points\", \"urgent\", \"severe degradation\", \"coordinated transition\"],\n    risk_narrative: \"Crisis-driven transformation with high capital reallocation\"\n  },\n  \"Sand in the gears\": {\n    query: \"nature scenario severe degradation policy fragmentation conflicting signals disorderly transition operational disruption stranded assets\",\n    keywords: [\"disorderly\", \"fragmented policy\", \"conflicting\", \"disruption\", \"regulatory arbitrage\"],\n    risk_narrative: \"Chaotic transition with supply chain disruptions\"\n  },\n  \"Back of the list\": {\n    query: \"nature scenario moderate degradation low alignment delayed action underinvestment gradual risk accumulation sudden repricing\",\n    keywords: [\"delayed action\", \"underinvestment\", \"complacency\", \"tail risks\", \"gradual accumulation\"],\n    risk_narrative: \"Slow burn with potential sudden repricing\"\n  }\n};\n\n// ============================================================================\n// ECOSYSTEM SERVICE QUERY TEMPLATES (ENCORE-aligned)\n// ============================================================================\n\nconst SERVICE_QUERIES = {\n  // Provisioning Services\n  \"Surface Water\": {\n    query: \"surface water dependency water scarcity freshwater availability drought water allocation industrial water use competition\",\n    keywords: [\"water scarcity\", \"drought\", \"allocation\", \"abstraction\", \"water stress\"],\n    transmission: [\"operational costs\", \"production disruption\", \"permit constraints\"],\n    critical_sectors: [\"mining\", \"energy\", \"food_agriculture\", \"manufacturing\"]\n  },\n  \"Ground Water\": {\n    query: \"groundwater dependency aquifer depletion groundwater abstraction subsidence recharge rates water table\",\n    keywords: [\"aquifer\", \"depletion\", \"subsidence\", \"recharge\", \"groundwater rights\"],\n    transmission: [\"long-term supply\", \"infrastructure damage\", \"regulatory limits\"],\n    critical_sectors: [\"mining\", \"food_agriculture\"]\n  },\n  \"Fibres & Other Materials\": {\n    query: \"biomass natural materials fibre supply raw materials timber cotton wool sustainable sourcing deforestation\",\n    keywords: [\"biomass\", \"raw materials\", \"sustainable sourcing\", \"deforestation-free\"],\n    transmission: [\"supply chain costs\", \"certification requirements\", \"reputational risk\"],\n    critical_sectors: [\"textiles\", \"manufacturing\"]\n  },\n  \"Genetic Materials\": {\n    query: \"genetic resources biodiversity bioprospecting Nagoya Protocol access benefit sharing pharmaceutical natural compounds\",\n    keywords: [\"genetic resources\", \"Nagoya Protocol\", \"ABS\", \"bioprospecting\"],\n    transmission: [\"R&D pipeline\", \"regulatory compliance\", \"license costs\"],\n    critical_sectors: [\"pharmaceuticals\"]\n  },\n  \n  // Regulating Services\n  \"Climate Regulation\": {\n    query: \"climate regulation ecosystem microclimate temperature regulation carbon sequestration heat stress cooling demand\",\n    keywords: [\"microclimate\", \"heat stress\", \"cooling\", \"carbon sink\", \"temperature regulation\"],\n    transmission: [\"energy costs\", \"worker productivity\", \"equipment efficiency\"],\n    critical_sectors: [\"energy\", \"manufacturing\", \"real_estate\"]\n  },\n  \"Flood & Storm Protection\": {\n    query: \"flood protection natural infrastructure coastal protection storm surge wetlands mangroves buffer zones erosion\",\n    keywords: [\"flood protection\", \"coastal erosion\", \"storm surge\", \"natural buffers\", \"wetlands\"],\n    transmission: [\"asset damage\", \"business interruption\", \"insurance costs\"],\n    critical_sectors: [\"transportation\", \"real_estate\", \"tourism\"]\n  },\n  \"Water Quality Regulation\": {\n    query: \"water quality ecosystem filtration purification effluent discharge pollution treatment wetland filtering\",\n    keywords: [\"water quality\", \"filtration\", \"effluent\", \"treatment costs\", \"discharge permits\"],\n    transmission: [\"treatment costs\", \"compliance fines\", \"operational permits\"],\n    critical_sectors: [\"mining\", \"manufacturing\", \"food_agriculture\"]\n  },\n  \"Soil Quality Regulation\": {\n    query: \"soil quality fertility erosion degradation soil health regenerative agriculture nutrient cycling\",\n    keywords: [\"soil fertility\", \"erosion\", \"degradation\", \"regenerative\", \"nutrient cycling\"],\n    transmission: [\"yield reduction\", \"input costs\", \"land value\"],\n    critical_sectors: [\"food_agriculture\", \"textiles\"]\n  },\n  \"Pollination\": {\n    query: \"pollination pollinator decline bee colony collapse crop yields agricultural dependence insect populations\",\n    keywords: [\"pollinator decline\", \"bee populations\", \"crop yields\", \"pollination services\"],\n    transmission: [\"yield losses\", \"hand pollination costs\", \"crop failure risk\"],\n    critical_sectors: [\"food_agriculture\"]\n  },\n  \"Pest & Disease Control\": {\n    query: \"pest control natural predators integrated pest management disease regulation biological control pesticide resistance\",\n    keywords: [\"pest control\", \"natural predators\", \"IPM\", \"pesticide resistance\"],\n    transmission: [\"crop losses\", \"chemical costs\", \"resistance management\"],\n    critical_sectors: [\"food_agriculture\"]\n  },\n  \"Erosion Control\": {\n    query: \"erosion control slope stability vegetation cover land degradation sedimentation coastal erosion infrastructure damage\",\n    keywords: [\"erosion\", \"slope stability\", \"sedimentation\", \"land degradation\"],\n    transmission: [\"infrastructure damage\", \"maintenance costs\", \"navigability\"],\n    critical_sectors: [\"transportation\", \"mining\", \"real_estate\"]\n  },\n  \"Mass Stabilisation & Erosion Control\": {\n    query: \"mass stabilisation landslide slope failure ground stability vegetation anchoring infrastructure protection\",\n    keywords: [\"landslide\", \"slope failure\", \"ground stability\", \"mass movement\"],\n    transmission: [\"infrastructure damage\", \"safety incidents\", \"closure costs\"],\n    critical_sectors: [\"mining\", \"transportation\", \"energy\"]\n  },\n  \"Air Quality Regulation\": {\n    query: \"air quality vegetation filtering particulate matter urban trees pollution absorption emission offsets\",\n    keywords: [\"air quality\", \"particulate matter\", \"pollution filtering\", \"urban vegetation\"],\n    transmission: [\"health costs\", \"compliance\", \"productivity\"],\n    critical_sectors: [\"real_estate\", \"manufacturing\"]\n  },\n  \n  // Cultural Services\n  \"Recreation & Tourism\": {\n    query: \"recreation tourism ecosystem nature-based tourism ecotourism visitor experience biodiversity attractions natural heritage\",\n    keywords: [\"ecotourism\", \"nature-based tourism\", \"visitor experience\", \"natural heritage\"],\n    transmission: [\"visitor numbers\", \"revenue\", \"destination value\"],\n    critical_sectors: [\"tourism\"]\n  },\n  \"Aesthetic Values\": {\n    query: \"aesthetic landscape scenic beauty viewshed natural landscape property values destination appeal visual amenity\",\n    keywords: [\"scenic beauty\", \"landscape\", \"viewshed\", \"amenity value\"],\n    transmission: [\"property values\", \"destination appeal\", \"brand value\"],\n    critical_sectors: [\"tourism\", \"real_estate\"]\n  }\n};\n\n// ============================================================================\n// SECTOR-SPECIFIC PATHWAY TEMPLATES\n// ============================================================================\n\nconst SECTOR_QUERIES = {\n  mining: {\n    query: \"mining sector nature risk water scarcity tailings biodiversity offsets closure rehabilitation permit social license\",\n    pathways: [\"water competition\", \"tailings failure\", \"biodiversity offset costs\", \"permit delays\"]\n  },\n  energy: {\n    query: \"energy sector nature risk cooling water hydropower variability grid resilience biomass sustainability renewable siting\",\n    pathways: [\"cooling constraints\", \"hydro variability\", \"siting conflicts\", \"grid vulnerability\"]\n  },\n  food_agriculture: {\n    query: \"agriculture food sector nature risk pollinator loss soil degradation water scarcity pest outbreaks climate variability yields\",\n    pathways: [\"yield decline\", \"input cost increase\", \"supply chain disruption\", \"land degradation\"]\n  },\n  tourism: {\n    query: \"tourism hospitality nature risk reef bleaching destination degradation wildlife decline visitor experience ecosystem health\",\n    pathways: [\"destination degradation\", \"visitor decline\", \"ecosystem collapse\", \"extreme weather\"]\n  },\n  real_estate: {\n    query: \"real estate property nature risk flooding heat island green infrastructure biodiversity net gain urban resilience\",\n    pathways: [\"flood damage\", \"heat stress\", \"BNG costs\", \"stranded assets\"]\n  },\n  transportation: {\n    query: \"transportation infrastructure nature risk flooding landslide erosion navigability climate resilience supply chain disruption\",\n    pathways: [\"infrastructure damage\", \"route disruption\", \"maintenance costs\", \"modal shift\"]\n  },\n  manufacturing: {\n    query: \"manufacturing industrial nature risk water supply effluent permits raw materials supply chain environmental compliance\",\n    pathways: [\"water constraints\", \"permit tightening\", \"supply disruption\", \"compliance costs\"]\n  },\n  pharmaceuticals: {\n    query: \"pharmaceutical biotech nature risk genetic resources bioprospecting ABS Nagoya supply chain natural compounds\",\n    pathways: [\"R&D pipeline\", \"ABS compliance\", \"supply chain\", \"regulatory access\"]\n  },\n  textiles: {\n    query: \"textile apparel nature risk cotton water deforestation supply chain EUDR sustainable materials certification\",\n    pathways: [\"water constraints\", \"raw material costs\", \"deforestation regulation\", \"certification\"]\n  },\n  financial: {\n    query: \"financial services nature risk portfolio exposure TNFD disclosure stress testing biodiversity credit risk underwriting\",\n    pathways: [\"portfolio exposure\", \"stranded assets\", \"credit risk\", \"underwriting losses\"]\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\n/**\n * Safe get nested value\n */\nfunction safeGet(obj, path, defaultValue = null) {\n  try {\n    return path.split('.').reduce((acc, part) => acc?.[part], obj) ?? defaultValue;\n  } catch {\n    return defaultValue;\n  }\n}\n\n/**\n * Build a query object with metadata\n */\nfunction buildQuery(type, query, intent, topK, priority, metadata = {}) {\n  return {\n    type,\n    query,\n    intent,\n    top_k: topK,\n    priority,\n    ...metadata\n  };\n}\n\n/**\n * Truncate query to reasonable length (embedding models have limits)\n */\nfunction truncateQuery(query, maxLength = 500) {\n  if (query.length <= maxLength) return query;\n  return query.substring(0, maxLength).trim();\n}\n\n// ============================================================================\n// MAIN QUERY BUILDING LOGIC\n// ============================================================================\n\nconst asset = $json.asset || {};\nconst nd = $json.nature_dependency || {};\nconst frame = $json.tnfd_scenario_frame || {};\nconst biome = $json.biome || {};\nconst biodiv = $json.biodiversity_gbif_iucn || {};\n\nconst dependencies = nd.dependencies || [];\nconst matchedSectors = nd.matched_sectors || [];\nconst envContext = nd.environmental_context || {};\n\nconst scenarioName = safeGet(frame, 'scenario.scenario_name') || \"Unknown scenario\";\nconst scenarioId = safeGet(frame, 'scenario.scenario_id') || null;\nconst horizonYear = frame.horizon_year || 2030;\n\nconst sector = asset.sector || nd.sector || \"Unknown\";\nconst country = asset.country || \"Unknown\";\nconst assetType = asset.asset_type || nd.asset_type || \"unknown\";\n\nconst biomeName = biome.biome_name || envContext.biome || null;\nconst ecoName = biome.eco_name || envContext.ecoregion || null;\n\n// ============================================================================\n// BUILD QUERY ARRAY\n// ============================================================================\n\nconst queries = [];\n\n// 1. FRAMEWORK QUERY - Always include LEAP Assess for scenario analysis\nqueries.push(buildQuery(\n  \"framework\",\n  FRAMEWORK_QUERIES.leap_assess.query + ` ${scenarioName} horizon ${horizonYear}`,\n  FRAMEWORK_QUERIES.leap_assess.intent,\n  CONFIG.topK.framework,\n  CONFIG.queryPriority.framework,\n  { doc_types: FRAMEWORK_QUERIES.leap_assess.doc_types }\n));\n\n// 2. SCENARIO NARRATIVE QUERY\nconst scenarioTemplate = SCENARIO_QUERIES[scenarioName];\nif (scenarioTemplate) {\n  queries.push(buildQuery(\n    \"scenario\",\n    scenarioTemplate.query,\n    `Retrieve narrative context for \"${scenarioName}\" scenario`,\n    CONFIG.topK.scenario,\n    CONFIG.queryPriority.scenario,\n    { \n      keywords: scenarioTemplate.keywords,\n      risk_narrative: scenarioTemplate.risk_narrative \n    }\n  ));\n}\n\n// 3. CRITICAL ECOSYSTEM SERVICE QUERIES (Very High and High dependencies only)\nconst criticalDeps = dependencies.filter(d => \n  d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\"\n);\n\nfor (const dep of criticalDeps.slice(0, 3)) { // Max 3 critical services\n  const serviceName = dep.ecosystem_service;\n  const serviceTemplate = SERVICE_QUERIES[serviceName];\n  \n  if (serviceTemplate) {\n    // Build service-specific query with asset context\n    const serviceQuery = `${serviceTemplate.query} ${sector} ${country} ${assetType}`;\n    \n    queries.push(buildQuery(\n      \"service_critical\",\n      truncateQuery(serviceQuery),\n      `Retrieve degradation pathways for ${serviceName} (${dep.dependency_strength} dependency)`,\n      CONFIG.topK.service,\n      CONFIG.queryPriority.service_critical,\n      {\n        ecosystem_service: serviceName,\n        dependency_strength: dep.dependency_strength,\n        transmission_channels: serviceTemplate.transmission,\n        keywords: serviceTemplate.keywords\n      }\n    ));\n  }\n}\n\n// 4. SECTOR-SPECIFIC PATHWAY QUERY\nconst primarySector = matchedSectors[0] || \"manufacturing\";\nconst sectorTemplate = SECTOR_QUERIES[primarySector];\n\nif (sectorTemplate) {\n  const sectorQuery = `${sectorTemplate.query} ${country} ${scenarioName}`;\n  \n  queries.push(buildQuery(\n    \"sector\",\n    truncateQuery(sectorQuery),\n    `Retrieve sector-specific nature risk pathways for ${primarySector}`,\n    CONFIG.topK.sector,\n    CONFIG.queryPriority.sector,\n    {\n      sector: primarySector,\n      pathways: sectorTemplate.pathways\n    }\n  ));\n}\n\n// 5. FINANCIAL TRANSMISSION QUERY (if we have financial exposure data)\nif (asset.value_eur && Number(asset.value_eur) > 0) {\n  const financialQuery = `nature risk financial transmission EBITDA revenue costs capital expenditure downtime business interruption ${sector}`;\n  \n  queries.push(buildQuery(\n    \"financial\",\n    truncateQuery(financialQuery),\n    \"Retrieve financial transmission channel guidance\",\n    CONFIG.topK.financial,\n    CONFIG.queryPriority.financial,\n    { doc_types: [\"guidance\", \"methodology\", \"transmission\"] }\n  ));\n}\n\n// Sort by priority and limit to max queries\nqueries.sort((a, b) => a.priority - b.priority);\nconst finalQueries = queries.slice(0, CONFIG.maxQueries);\n\n// ============================================================================\n// BUILD COMBINED QUERY (backward compatibility)\n// ============================================================================\n\nconst combinedQueryParts = finalQueries.map(q => q.query);\nconst combinedQuery = combinedQueryParts.join(\" | \");\n\n// ============================================================================\n// BUILD FILTERS\n// ============================================================================\n\n// Metadata filters for Pinecone (adjust keys to match your index schema)\nconst rag_filters = {\n  // Framework filter\n  framework: { \"$in\": [\"TNFD\", \"NGFS\", \"DNB\", \"ENCORE\", \"SBTN\"] },\n  \n  // Document type filter\n  doc_type: { \"$in\": [\"guidance\", \"scenario\", \"pathway\", \"methodology\", \"transmission\"] },\n  \n  // Scenario filter (if your index has this)\n  ...(scenarioId ? { tnfd_scenario_id: scenarioId } : {}),\n  \n  // Sector filter (if your index has this)\n  ...(matchedSectors.length > 0 ? { \n    sector: { \"$in\": matchedSectors } \n  } : {}),\n  \n  // Ecosystem service filter (if your index has this)\n  ...(criticalDeps.length > 0 ? {\n    ecosystem_service: { \n      \"$in\": criticalDeps.map(d => d.ecosystem_service_id || d.ecosystem_service.toLowerCase().replace(/ /g, \"_\"))\n    }\n  } : {})\n};\n\n// ============================================================================\n// BUILD RETRIEVAL STRATEGY EXPLANATION\n// ============================================================================\n\nconst rag_strategy = {\n  approach: \"Multi-query focused retrieval\",\n  rationale: \"Single large queries dilute semantic focus. Multiple targeted queries improve precision.\",\n  query_count: finalQueries.length,\n  total_chunks_target: finalQueries.reduce((sum, q) => sum + q.top_k, 0),\n  query_breakdown: finalQueries.map(q => ({\n    type: q.type,\n    intent: q.intent,\n    top_k: q.top_k\n  })),\n  context_used: {\n    scenario: scenarioName,\n    sector: primarySector,\n    critical_services: criticalDeps.map(d => d.ecosystem_service),\n    country: country,\n    biome: biomeName\n  }\n};\n\n// ============================================================================\n// BUILD INTENT OBJECT (for debugging/explainability)\n// ============================================================================\n\nconst rag_intent = {\n  scenarioName,\n  scenarioId,\n  sector,\n  country,\n  assetType,\n  biomeName,\n  ecoName,\n  horizon_year: horizonYear,\n  critical_dependencies: criticalDeps.map(d => ({\n    service: d.ecosystem_service,\n    strength: d.dependency_strength,\n    substitutability: d.substitutability,\n    time_to_failure: d.time_to_failure\n  })),\n  matched_sectors: matchedSectors,\n  environmental_context: {\n    water_stress: envContext.water_stress_level,\n    biodiversity_sensitivity: envContext.biodiversity_sensitivity,\n    biome_sensitivity: envContext.biome_sensitivity_factor\n  }\n};\n\n// ============================================================================\n// OUTPUT\n// ============================================================================\n\nreturn {\n  ...$json,\n  \n  // New: Array of focused queries (for advanced RAG implementations)\n  rag_queries: finalQueries,\n  \n  // Backward compatible: Combined query string\n  rag_query: combinedQuery,\n  \n  // Backward compatible: Top-K (sum of all query top_k)\n  rag_top_k: finalQueries.reduce((sum, q) => sum + q.top_k, 0),\n  \n  // Backward compatible: Filters\n  rag_filters,\n  \n  // New: Strategy explanation\n  rag_strategy,\n  \n  // Enhanced: Intent object for debugging\n  rag_intent\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8176,
        1616
      ],
      "id": "c6da8d30-636c-4081-9fdb-a5081b5a6120",
      "name": "Query builder for RAG"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Initialize Loop Context\n * Sets up the iteration context for the evaluation-optimizer loop\n */\n\nconst input = $json;\n\n// Initialize loop context\nconst loopContext = {\n  attempt_number: 0,\n  max_attempts: 3,\n  evaluation_history: [],\n  previous_feedback: null,\n  pathway_output: null,\n  approved: false\n};\n\nreturn {\n  ...input,\n  loopContext\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7376,
        1408
      ],
      "id": "7b7a5049-4276-481d-8f71-9e8898d714e8",
      "name": "Initialize loop context"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.evidence_synthesizer_prompt.user }}",
        "options": {
          "systemMessage": "={{ $json.evidence_synthesizer_prompt.system }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        9168,
        1328
      ],
      "id": "35c7e90d-864e-478f-b567-0626be1a9f20",
      "name": "Evidence Synthesizer"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Parse Evidence Output\n * \n * PURPOSE:\n * Parses the JSON response from Agent 1 (Evidence Synthesizer)\n * Handles various response formats including markdown code fences\n * \n * HANDLES:\n * - Raw JSON: {\"evidence_synthesis\": {...}}\n * - Markdown fenced: ```json\\n{...}\\n```\n * - With output wrapper: {\"output\": \"```json\\n{...}\\n```\"}\n * - Array wrapper: [{\"output\": \"...\"}]\n */\n\n// Get the raw response - handle different input structures\nlet rawResponse = $json;\n\n// If it's an array, get first element\nif (Array.isArray(rawResponse)) {\n  rawResponse = rawResponse[0];\n}\n\n// If there's an \"output\" field (common n8n AI node pattern), use that\nlet responseText = rawResponse.output || \n                   rawResponse.message?.content || \n                   rawResponse.text ||\n                   rawResponse.response ||\n                   (typeof rawResponse === 'string' ? rawResponse : JSON.stringify(rawResponse));\n\n// If responseText is still an object with nested output, extract it\nif (typeof responseText === 'object' && responseText.output) {\n  responseText = responseText.output;\n}\n\n// Ensure we have a string to work with\nif (typeof responseText !== 'string') {\n  responseText = JSON.stringify(responseText);\n}\n\nlet evidence_synthesis = null;\nlet parseError = null;\n\ntry {\n  // Step 1: Try direct JSON parse (in case it's clean JSON)\n  evidence_synthesis = JSON.parse(responseText);\n} catch (e1) {\n  try {\n    // Step 2: Try extracting from markdown code fence\n    // This regex handles ```json, ``` , and variations with newlines\n    const codeBlockMatch = responseText.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n    \n    if (codeBlockMatch && codeBlockMatch[1]) {\n      const extracted = codeBlockMatch[1].trim();\n      evidence_synthesis = JSON.parse(extracted);\n    } else {\n      // Step 3: Try finding JSON object directly (starts with { ends with })\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        evidence_synthesis = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error(\"No JSON structure found in response\");\n      }\n    }\n  } catch (e2) {\n    parseError = `Parse failed: ${e2.message}. First 500 chars: ${responseText.substring(0, 500)}`;\n  }\n}\n\n// Extract the evidence_synthesis object if it's nested\nif (evidence_synthesis && evidence_synthesis.evidence_synthesis) {\n  evidence_synthesis = evidence_synthesis.evidence_synthesis;\n}\n\n// Get the previous node's data to merge\n// Adjust the node name to match your actual node name\nconst previousData = $('Build Evidence Synthesizer Prompt').item?.json || $json || {};\n\n// Build output\nif (evidence_synthesis && !parseError) {\n  return {\n    ...previousData,\n    evidence_synthesis: evidence_synthesis,\n    _parse_status: \"success\"\n  };\n} else {\n  // Return with error info for debugging, but don't fail the workflow\n  return {\n    ...previousData,\n    evidence_synthesis: {\n      error: parseError || \"Unknown parse error\",\n      raw_response_preview: responseText.substring(0, 1000),\n      pathways: [] // Empty array so downstream doesn't break\n    },\n    _parse_status: \"failed\",\n    _parse_error: parseError\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9600,
        1328
      ],
      "id": "cec7a58d-f11e-4f48-858d-d3f2f745394f",
      "name": "Parse Evidence Output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Parse Strategy Output\n * \n * PURPOSE:\n * Parses the JSON response from Agent 2 (Adaptation Strategist)\n * Handles various response formats including markdown code fences\n * \n * HANDLES:\n * - Raw JSON: {\"adaptation_strategy\": {...}}\n * - Markdown fenced: ```json\\n{...}\\n```\n * - With output wrapper: {\"output\": \"```json\\n{...}\\n```\"}\n * - Array wrapper: [{\"output\": \"...\"}]\n */\n\n// Get the raw response - handle different input structures\nlet rawResponse = $json;\n\n// If it's an array, get first element\nif (Array.isArray(rawResponse)) {\n  rawResponse = rawResponse[0];\n}\n\n// If there's an \"output\" field (common n8n AI node pattern), use that\nlet responseText = rawResponse.output || \n                   rawResponse.message?.content || \n                   rawResponse.text ||\n                   rawResponse.response ||\n                   (typeof rawResponse === 'string' ? rawResponse : JSON.stringify(rawResponse));\n\n// If responseText is still an object with nested output, extract it\nif (typeof responseText === 'object' && responseText.output) {\n  responseText = responseText.output;\n}\n\n// Ensure we have a string to work with\nif (typeof responseText !== 'string') {\n  responseText = JSON.stringify(responseText);\n}\n\nlet adaptation_strategy = null;\nlet parseError = null;\n\ntry {\n  // Step 1: Try direct JSON parse (in case it's clean JSON)\n  adaptation_strategy = JSON.parse(responseText);\n} catch (e1) {\n  try {\n    // Step 2: Try extracting from markdown code fence\n    const codeBlockMatch = responseText.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n    \n    if (codeBlockMatch && codeBlockMatch[1]) {\n      const extracted = codeBlockMatch[1].trim();\n      adaptation_strategy = JSON.parse(extracted);\n    } else {\n      // Step 3: Try finding JSON object directly (starts with { ends with })\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        adaptation_strategy = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error(\"No JSON structure found in response\");\n      }\n    }\n  } catch (e2) {\n    parseError = `Parse failed: ${e2.message}. First 500 chars: ${responseText.substring(0, 500)}`;\n  }\n}\n\n// Extract the adaptation_strategy object if it's nested\nif (adaptation_strategy && adaptation_strategy.adaptation_strategy) {\n  adaptation_strategy = adaptation_strategy.adaptation_strategy;\n}\n\n// Get the previous node's data to merge\n// Adjust the node name to match your actual node name\nconst previousData = $('Build Adaptation Strategist Prompt').item?.json || \n                     $('Agent 2: Adaptation Strategist').item?.json ||\n                     $json || {};\n\n// Build output\nif (adaptation_strategy && !parseError) {\n  return {\n    ...previousData,\n    adaptation_strategy: adaptation_strategy,\n    _parse_status: \"success\"\n  };\n} else {\n  // Return with error info for debugging, but don't fail the workflow\n  return {\n    ...previousData,\n    adaptation_strategy: {\n      error: parseError || \"Unknown parse error\",\n      raw_response_preview: responseText.substring(0, 1000),\n      pathway_strategies: [] // Empty array so downstream doesn't break\n    },\n    _parse_status: \"failed\",\n    _parse_error: parseError\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10496,
        1328
      ],
      "id": "5b249cb2-4aab-438e-ad3a-e48233d5fbdb",
      "name": "Parse Strategy Output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * AGENT 3: Narrative Intelligence (v2.1 - With Feedback Loop Support)\n * \n * PURPOSE:\n * Transforms the structured analysis into stakeholder-specific communications.\n * Generates multiple output formats tailored to different audiences.\n * \n * KEY CHANGE IN v2.1: Feedback Loop Support\n * - Checks for evaluator feedback from previous iteration\n * - Incorporates improvement guidance into the prompt\n * - Tracks attempt number for context\n * \n * POSITION IN PIPELINE:\n * After: Parse Strategy Output (INSIDE the feedback loop)\n * Before: Parse Narrative Output → Build Evaluator Prompt\n * \n * INPUTS:\n * - $json.nature_dependency (dependencies)\n * - $json.tnfd_scenario_frame (scenario)\n * - $json.evidence_synthesis (grounded pathways)\n * - $json.adaptation_strategy (strategies)\n * - $json.financial_impact (financial exposure)\n * - $json.asset (asset context)\n * - $json.agent_attempt (iteration number)\n * - $json.evaluation_feedback (from Evaluator, if retry)\n * \n * N8N CONFIGURATION:\n * - Node Type: Code\n * - Mode: Run Once for Each Item\n * - Position: INSIDE the feedback loop\n */\n\n// ============================================================================\n// SYSTEM PROMPT\n// ============================================================================\n\nconst NARRATIVE_INTELLIGENCE_SYSTEM_PROMPT = `You are a Narrative Intelligence specialist who transforms complex nature-risk analyses into compelling, audience-appropriate communications. You understand that different stakeholders need different framings of the same underlying analysis.\n\n## YOUR TASK\n\nGiven a complete nature-risk analysis (dependencies, scenario, evidence, strategies, financials), generate tailored narratives for five distinct audiences:\n\n1. **Executive Summary** - For C-suite and board members who need the strategic headline\n2. **CFO Brief** - For financial leadership focused on P&L, capital, and disclosure\n3. **Sustainability Report Section** - For TNFD/CSRD-aligned external disclosure\n4. **Risk Committee Memo** - For governance bodies focused on risk oversight\n5. **Operational Brief** - For site/asset managers who will implement changes\n\n## OUTPUT FORMAT\n\nYou MUST respond with valid JSON matching this exact schema:\n\n{\n  \"stakeholder_narratives\": {\n    \"asset_id\": \"string\",\n    \"generated_at\": \"ISO datetime\",\n    \"attempt_number\": 1,\n    \n    \"executive_summary\": {\n      \"audience\": \"C-Suite, Board of Directors\",\n      \"reading_time\": \"2 minutes\",\n      \"headline\": \"string (single compelling sentence)\",\n      \"key_message\": \"string (2-3 sentences: what, so what, now what)\",\n      \"risk_rating\": {\n        \"level\": \"Critical | High | Moderate | Low\",\n        \"trend\": \"Increasing | Stable | Decreasing\",\n        \"confidence\": \"High | Medium | Low\"\n      },\n      \"financial_headline\": \"string (single sentence on financial exposure)\",\n      \"strategic_imperative\": \"string (what leadership must decide/enable)\",\n      \"recommended_board_action\": \"string (specific ask for board)\",\n      \"narrative\": \"string (3-4 paragraph executive narrative)\"\n    },\n    \n    \"cfo_brief\": {\n      \"audience\": \"CFO, Finance Leadership, Investor Relations\",\n      \"reading_time\": \"5 minutes\",\n      \"financial_exposure_summary\": {\n        \"headline_figure\": \"string (e.g., '€15-25M potential exposure by 2030')\",\n        \"breakdown\": {\n          \"operational_costs\": \"string\",\n          \"capital_requirements\": \"string\", \n          \"revenue_at_risk\": \"string\",\n          \"potential_impairments\": \"string\"\n        },\n        \"comparison_to_ebitda\": \"string\",\n        \"confidence_note\": \"string\"\n      },\n      \"disclosure_implications\": {\n        \"tnfd_alignment\": \"string\",\n        \"csrd_materiality\": \"string\",\n        \"investor_pressure\": \"string\"\n      },\n      \"investment_case\": {\n        \"proposed_investment\": \"string\",\n        \"risk_reduction_value\": \"string\",\n        \"payback_logic\": \"string\"\n      },\n      \"narrative\": \"string (4-5 paragraph financial narrative)\"\n    },\n    \n    \"sustainability_report_section\": {\n      \"audience\": \"External stakeholders, ESG analysts, regulators\",\n      \"reading_time\": \"7 minutes\",\n      \"tnfd_pillar_alignment\": {\n        \"governance\": \"string\",\n        \"strategy\": \"string\",\n        \"risk_management\": \"string\",\n        \"metrics_targets\": \"string\"\n      },\n      \"leap_process_summary\": {\n        \"locate\": \"string\",\n        \"evaluate\": \"string\",\n        \"assess\": \"string\",\n        \"prepare\": \"string\"\n      },\n      \"scenario_disclosure\": {\n        \"scenario_used\": \"string\",\n        \"key_assumptions\": [\"string\"],\n        \"time_horizons\": [\"string\"],\n        \"limitations\": [\"string\"]\n      },\n      \"commitments\": [\n        {\n          \"commitment\": \"string\",\n          \"target_year\": \"string\",\n          \"baseline\": \"string\",\n          \"progress_indicator\": \"string\"\n        }\n      ],\n      \"narrative\": \"string (5-6 paragraph disclosure-ready narrative)\"\n    },\n    \n    \"risk_committee_memo\": {\n      \"audience\": \"Board Risk Committee, Group Risk Function\",\n      \"reading_time\": \"5 minutes\",\n      \"risk_classification\": {\n        \"risk_type\": \"Strategic | Operational | Financial | Compliance\",\n        \"risk_category\": \"Nature-related Physical Risk | Nature-related Transition Risk\",\n        \"inherent_risk_rating\": \"Critical | High | Medium | Low\",\n        \"control_effectiveness\": \"Strong | Adequate | Needs Improvement | Weak\",\n        \"residual_risk_rating\": \"Critical | High | Medium | Low\"\n      },\n      \"risk_appetite_alignment\": \"string\",\n      \"control_environment\": {\n        \"existing_controls\": [\"string\"],\n        \"control_gaps\": [\"string\"],\n        \"recommended_enhancements\": [\"string\"]\n      },\n      \"escalation_triggers\": [\n        {\n          \"trigger\": \"string\",\n          \"threshold\": \"string\",\n          \"escalation_path\": \"string\"\n        }\n      ],\n      \"narrative\": \"string (4-5 paragraph risk governance narrative)\"\n    },\n    \n    \"operational_brief\": {\n      \"audience\": \"Site managers, Asset managers, Operations teams\",\n      \"reading_time\": \"10 minutes\",\n      \"situation_summary\": \"string (plain-language risk explanation)\",\n      \"why_this_matters_locally\": \"string (translate to operational reality)\",\n      \"immediate_actions\": [\n        {\n          \"action\": \"string\",\n          \"owner\": \"string (role)\",\n          \"deadline\": \"string\",\n          \"resources_needed\": \"string\",\n          \"success_criteria\": \"string\"\n        }\n      ],\n      \"monitoring_requirements\": [\n        {\n          \"what_to_monitor\": \"string\",\n          \"frequency\": \"string\",\n          \"escalation_threshold\": \"string\",\n          \"reporting_to\": \"string\"\n        }\n      ],\n      \"scenario_planning\": {\n        \"if_moderate_degradation\": \"string\",\n        \"if_severe_degradation\": \"string\",\n        \"emergency_contacts\": \"string\"\n      },\n      \"training_needs\": [\"string\"],\n      \"narrative\": \"string (4-5 paragraph operational narrative)\"\n    },\n    \n    \"key_messages_summary\": {\n      \"one_liner\": \"string (10 seconds)\",\n      \"elevator_pitch\": \"string (60 seconds)\",\n      \"three_key_points\": [\"string\", \"string\", \"string\"],\n      \"call_to_action\": \"string\"\n    },\n    \n    \"revision_notes\": \"string (if revision, note what was improved)\",\n    \n    \"narrative_methodology\": {\n      \"inputs_used\": [\"string\"],\n      \"framing_approach\": \"string\",\n      \"limitations\": [\"string\"]\n    }\n  }\n}\n\n## NARRATIVE PRINCIPLES\n\n1. **Audience-first**: Each narrative should feel written specifically for that audience\n2. **Concrete over abstract**: Specific examples and numbers, not vague statements\n3. **So-what clarity**: Every fact connects to an implication\n4. **Action orientation**: End each narrative with clear next steps\n5. **Calibrated confidence**: Be clear about certainty vs. uncertainty\n6. **Disclosure-ready**: Sustainability section should be usable in actual reports\n7. **Avoid jargon leakage**: Adapt vocabulary to each audience\n\n## TONE BY AUDIENCE\n\n- **Executive Summary**: Strategic, decisive, high-level\n- **CFO Brief**: Quantitative, risk-adjusted, disclosure-aware\n- **Sustainability Report**: Formal, balanced, framework-aligned\n- **Risk Committee**: Governance-focused, control-oriented\n- **Operational Brief**: Practical, concrete, action-focused\n\n## IF THIS IS A REVISION\n\nIf you see a \"REVISION REQUIRED\" section in the prompt:\n1. **Read the feedback carefully** - understand what was wrong\n2. **Fix accuracy issues** - ensure narratives match underlying data\n3. **Improve audience fit** - make each narrative more distinct\n4. **Add missing actions** - ensure actionability in each section\n5. **Adjust tone** - calibrate language to audience\n6. **Note changes** in revision_notes field\n\n## LENGTH GUIDANCE\n\n- Executive Summary narrative: 300-400 words\n- CFO Brief narrative: 400-500 words\n- Sustainability Report narrative: 500-600 words\n- Risk Committee narrative: 400-500 words\n- Operational Brief narrative: 400-500 words`;\n\n// ============================================================================\n// FEEDBACK SECTION BUILDER\n// ============================================================================\n\nfunction buildFeedbackSection(data) {\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  const feedback = data.evaluation_feedback || data.previous_feedback || data.evaluation_result || null;\n  \n  if (attemptNumber <= 1 || !feedback) {\n    return '';\n  }\n  \n  const agentEval = feedback.agent_evaluations?.narrative_intelligence || \n                    feedback.narrative_intelligence || {};\n  \n  const score = agentEval.score || 'N/A';\n  const criticalIssues = agentEval.critical_issues || [];\n  const improvementFeedback = agentEval.improvement_feedback || 'No specific feedback provided.';\n  const criteriaScores = agentEval.criteria_scores || {};\n  \n  const weakCriteria = Object.entries(criteriaScores)\n    .filter(([_, v]) => v && v.score < 75)\n    .map(([k, v]) => `- **${k}** (${v.score}/100): ${v.notes || 'Needs improvement'}`)\n    .join('\\n');\n  \n  // Check for factual accuracy issues\n  const hallucinations = feedback.hallucination_check?.instances || [];\n  const narrativeHallucinations = hallucinations.filter(h => h.agent === 'narrative_intelligence');\n  \n  let hallucinationWarning = '';\n  if (narrativeHallucinations.length > 0) {\n    hallucinationWarning = `\n### ⚠️ FACTUAL ACCURACY ISSUES DETECTED\n\nThe following claims didn't match the underlying data:\n${narrativeHallucinations.map(h => `- \"${h.claim}\" - Issue: ${h.issue}`).join('\\n')}\n\n**Ensure all narratives accurately reflect the evidence and strategy outputs.**\n`;\n  }\n  \n  // Check ground truth alignment\n  const groundTruth = feedback.ground_truth_alignment || {};\n  let alignmentWarning = '';\n  if (groundTruth.financial_consistency && groundTruth.financial_consistency.includes('mismatch')) {\n    alignmentWarning = `\n### Financial Consistency Issue\n${groundTruth.financial_consistency}\n\n**The financial figures in narratives must match the financial_impact data.**\n`;\n  }\n  \n  // Cross-agent consistency\n  const consistencyIssues = feedback.cross_agent_consistency?.issues || [];\n  let consistencyWarning = '';\n  if (consistencyIssues.length > 0) {\n    consistencyWarning = `\n### Cross-Agent Consistency Issues\n${consistencyIssues.map(i => `- ${i}`).join('\\n')}\n\n**Narratives must accurately reflect evidence synthesis and adaptation strategy outputs.**\n`;\n  }\n  \n  return `\n## ⚠️ REVISION REQUIRED (Attempt ${attemptNumber} of 3)\n\nYour previous output was evaluated and needs improvement.\n\n### Evaluation Score: ${score}/100 ${score >= 75 ? '(Passed but needs refinement)' : '(Below threshold)'}\n\n### Critical Issues to Address:\n${criticalIssues.length > 0 ? criticalIssues.map(i => `- ❌ ${i}`).join('\\n') : '- No critical issues flagged'}\n\n### Specific Improvement Guidance:\n${improvementFeedback}\n\n### Criteria Needing Improvement:\n${weakCriteria || '- All criteria met minimum threshold'}\n${hallucinationWarning}${alignmentWarning}${consistencyWarning}\n\n### Common Narrative Issues to Avoid:\n- **Generic narratives**: Each audience section should feel distinctly different\n- **Data mismatches**: Financial figures must match input data exactly\n- **Missing actions**: Each narrative needs clear next steps for that audience\n- **Wrong tone**: Executive summary shouldn't read like operational brief\n- **Disclosure gaps**: Sustainability section must align with TNFD pillars\n\n---\n\n`;\n}\n\n// ============================================================================\n// USER PROMPT BUILDER\n// ============================================================================\n\nfunction buildNarrativeIntelligencePrompt(data) {\n  const asset = data.asset || {};\n  const nd = data.nature_dependency || {};\n  const frame = data.tnfd_scenario_frame || {};\n  const evidence = data.evidence_synthesis || {};\n  const strategy = data.adaptation_strategy || {};\n  const financial = data.financial_impact || data.shock_grid || {};\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  \n  // Build feedback section\n  const feedbackSection = buildFeedbackSection(data);\n  \n  // Summarize critical dependencies\n  const criticalDeps = (nd.dependencies || [])\n    .filter(d => d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\")\n    .map(d => `${d.ecosystem_service} (${d.dependency_strength})`);\n  \n  // Summarize evidence pathways\n  const pathwaySummaries = (evidence.pathways || []).map(p => {\n    return `- ${p.pathway_name}: Evidence strength ${p.evidence_assessment?.strength || 'Unknown'}`;\n  });\n  \n  // Summarize key strategies\n  const strategySummaries = (strategy.pathway_strategies || []).flatMap(ps => {\n    const shortTerm = (ps.short_term_actions?.actions || []).map(a => `[ST] ${a.title}`);\n    const medTerm = (ps.medium_term_investments?.actions || []).map(a => `[MT] ${a.title}`);\n    return [...shortTerm.slice(0, 2), ...medTerm.slice(0, 1)];\n  });\n  \n  // Financial summary\n  let financialSummary = 'Financial exposure not quantified.';\n  if (financial.severe_total_eur || financial.total_exposure) {\n    financialSummary = `\nTotal Exposure (Severe): €${(financial.severe_total_eur || financial.total_exposure || 0).toLocaleString()}\n- OPEX: €${(financial.opex_eur || 0).toLocaleString()}\n- CAPEX: €${(financial.capex_eur || 0).toLocaleString()}\n- Revenue: €${(financial.revenue_eur || 0).toLocaleString()}`;\n  }\n  \n  // Investment summary from strategy\n  let investmentSummary = 'Investment requirements not specified.';\n  if (strategy.strategic_overview?.total_estimated_investment) {\n    const inv = strategy.strategic_overview.total_estimated_investment;\n    investmentSummary = `€${(inv.low || 0).toLocaleString()} - €${(inv.high || 0).toLocaleString()} (${inv.confidence} confidence)`;\n  }\n\n  return `${feedbackSection}## COMPLETE ANALYSIS SUMMARY\n\n### Asset Profile\n- Asset ID: ${asset.asset_id || 'Unknown'}\n- Sector: ${nd.sector || asset.sector || 'Unknown'}\n- Asset Type: ${nd.asset_type || asset.asset_type || 'Unknown'}\n- Country: ${asset.country || 'Unknown'}\n- Value: €${(asset.value_eur || 0).toLocaleString()}\n- Biome: ${nd.environmental_context?.biome || 'Unknown'}\n- Analysis Attempt: ${attemptNumber} of 3\n\n### Scenario Context\n- Scenario: ${frame.scenario?.scenario_name || 'Unknown'}\n- Description: ${frame.scenario_detail?.description || 'Not available'}\n- Risk Posture: ${frame.scenario_detail?.risk_posture || 'Not specified'}\n- Typical Response: ${frame.scenario_detail?.typical_response || 'Not specified'}\n- Physical Risk Score: ${frame.axes?.ecosystem_service_degradation?.toFixed(2) || 'N/A'} (${frame.physical_axis_detail?.interpretation || ''})\n- Transition Risk Score: ${frame.axes?.market_nonmarket_alignment?.toFixed(2) || 'N/A'} (${frame.transition_axis_detail?.interpretation || ''})\n- Horizon: ${frame.horizon_year || 2030}\n\n### Critical Dependencies\n${criticalDeps.length > 0 ? criticalDeps.join(', ') : 'None identified at Very High or High level'}\n\n### Evidence-Grounded Pathways\n${pathwaySummaries.length > 0 ? pathwaySummaries.join('\\n') : 'No pathways synthesized'}\n\n### Financial Exposure\n${financialSummary}\n\n### Proposed Investment\n${investmentSummary}\n\n### Key Strategies Identified\n${strategySummaries.length > 0 ? strategySummaries.join('\\n') : 'No strategies specified'}\n\n### Governance Recommendations\n${(strategy.governance_recommendations?.board_level || []).map(r => `- Board: ${r.recommendation}`).join('\\n') || 'None specified'}\n\n### Cross-Cutting Themes\n${(evidence.cross_cutting_themes || []).map(t => `- ${t.theme}`).join('\\n') || 'None identified'}\n\n### Knowledge Gaps\n${(evidence.knowledge_gaps || []).map(g => `- ${g.gap}`).join('\\n') || 'None identified'}\n\n---\n\n## YOUR TASK\n\nUsing all the above information, generate stakeholder-specific narratives for:\n1. Executive Summary (C-Suite, Board)\n2. CFO Brief (Finance, IR)\n3. Sustainability Report Section (External disclosure)\n4. Risk Committee Memo (Governance, Audit)\n5. Operational Brief (Site/Asset managers)\n\n### Requirements\n- Each narrative should feel **tailored to its audience**, not reformatted\n- **Financial figures must match** the data above exactly\n- Each section must end with **appropriate next steps** for that audience\n- The sustainability section must **align with TNFD pillars**\n${attemptNumber > 1 ? '- **Address all evaluator feedback** and note changes in revision_notes' : ''}\n\n### Quality Checklist\n☐ Does each narrative have a distinct tone?\n☐ Are financial figures consistent with input data?\n☐ Does each section have clear next steps?\n☐ Is the sustainability section TNFD-aligned?\n☐ Are risk ratings consistent across narratives?\n${attemptNumber > 1 ? '☐ Have I addressed all critical issues from the evaluator?' : ''}\n\nRespond with valid JSON only.`;\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\nconst userPrompt = buildNarrativeIntelligencePrompt($json);\nconst attemptNumber = $json.agent_attempt || $json.loopContext?.attempt_number || 1;\n\nreturn {\n  ...$json,\n  narrative_intelligence_prompt: {\n    system: NARRATIVE_INTELLIGENCE_SYSTEM_PROMPT,\n    user: userPrompt\n  },\n  current_agent: \"narrative_intelligence\",\n  current_attempt: attemptNumber\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        10720,
        1328
      ],
      "id": "d47c5e4e-af7c-4dc4-b73c-25291c43e1e1",
      "name": "Build Narrative Intelligence Prompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.narrative_intelligence_prompt.user }}",
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.narrative_intelligence_prompt.system }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        10944,
        1328
      ],
      "id": "da32a646-ac85-418a-8d01-2d740e246fd4",
      "name": "Narrative Intelligence"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 5000,
          "temperature": 0.5
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        11024,
        1552
      ],
      "id": "11e46cd6-bb4b-4353-aeaa-f591f6b56a12",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * Parse Narrative Output\n * \n * PURPOSE:\n * Parses the JSON response from Agent 3 (Narrative Intelligence)\n * Handles various response formats including markdown code fences\n * \n * HANDLES:\n * - Raw JSON: {\"stakeholder_narratives\": {...}}\n * - Markdown fenced: ```json\\n{...}\\n```\n * - With output wrapper: {\"output\": \"```json\\n{...}\\n```\"}\n * - Array wrapper: [{\"output\": \"...\"}]\n */\n\n// Get the raw response - handle different input structures\nlet rawResponse = $json;\n\n// If it's an array, get first element\nif (Array.isArray(rawResponse)) {\n  rawResponse = rawResponse[0];\n}\n\n// If there's an \"output\" field (common n8n AI node pattern), use that\nlet responseText = rawResponse.text || \n                   rawResponse.message?.content || \n                   rawResponse.text ||\n                   rawResponse.response ||\n                   (typeof rawResponse === 'string' ? rawResponse : JSON.stringify(rawResponse));\n\n// If responseText is still an object with nested output, extract it\nif (typeof responseText === 'object' && responseText.text) {\n  responseText = responseText.text;\n}\n\n// Ensure we have a string to work with\nif (typeof responseText !== 'string') {\n  responseText = JSON.stringify(responseText);\n}\n\nlet stakeholder_narratives = null;\nlet parseError = null;\n\ntry {\n  // Step 1: Try direct JSON parse (in case it's clean JSON)\n  stakeholder_narratives = JSON.parse(responseText);\n} catch (e1) {\n  try {\n    // Step 2: Try extracting from markdown code fence\n    const codeBlockMatch = responseText.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n    \n    if (codeBlockMatch && codeBlockMatch[1]) {\n      const extracted = codeBlockMatch[1].trim();\n      stakeholder_narratives = JSON.parse(extracted);\n    } else {\n      // Step 3: Try finding JSON object directly (starts with { ends with })\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        stakeholder_narratives = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error(\"No JSON structure found in response\");\n      }\n    }\n  } catch (e2) {\n    parseError = `Parse failed: ${e2.message}. First 500 chars: ${responseText.substring(0, 500)}`;\n  }\n}\n\n// Extract the stakeholder_narratives object if it's nested\nif (stakeholder_narratives && stakeholder_narratives.stakeholder_narratives) {\n  stakeholder_narratives = stakeholder_narratives.stakeholder_narratives;\n}\n\n// Get the previous node's data to merge\n// Adjust the node name to match your actual node name\nconst previousData = $('Build Narrative Intelligence Prompt').item?.json || \n                     $('Agent 3: Narrative Intelligence').item?.json ||\n                     $json || {};\n\n// Build output\nif (stakeholder_narratives && !parseError) {\n  return {\n    ...previousData,\n    stakeholder_narratives: stakeholder_narratives,\n    _parse_status: \"success\"\n  };\n} else {\n  // Return with error info for debugging, but don't fail the workflow\n  return {\n    ...previousData,\n    stakeholder_narratives: {\n      error: parseError || \"Unknown parse error\",\n      raw_response_preview: responseText.substring(0, 1000),\n      executive_summary: null,\n      cfo_brief: null,\n      sustainability_report_section: null,\n      risk_committee_memo: null,\n      operational_brief: null\n    },\n    _parse_status: \"failed\",\n    _parse_error: parseError\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11312,
        1552
      ],
      "id": "de5f3052-7837-44d7-a23a-f413e7bc9aac",
      "name": "Parse Narrative Output"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Initialise Counter (v2.3 - FIXED Infinite Loop Bug)\n * \n * ROOT CAUSE OF BUG:\n * - loopContext.attempt_number was never being incremented\n * - The If2 node checked: attempt_number < max_attempts\n * - Since attempt_number stayed at 0, this was always true → infinite loop\n * \n * FIX:\n * - Track attempts using evaluation_history.length (reliable across iterations)\n * - If we have evaluation_result, we've completed an iteration → increment\n * - Output the correct attempt_number for If2 to check\n * \n * POSITION IN PIPELINE:\n * After: Merge1 (first time) OR Merge Feedback (on retry)\n * Before: Build Evidence Synthesizer Prompt\n */\n\nconst input = $json;\n\n// ============================================================================\n// DETERMINE CURRENT ATTEMPT NUMBER (FIXED!)\n// ============================================================================\n\n// Get evaluation history - this is our source of truth\nconst existingHistory = input.loopContext?.evaluation_history || [];\n\n// Check if we have evaluation results (meaning we've been through at least once)\nconst hasEvaluationResult = !!input.evaluation_result;\nconst hasEvaluationFeedback = !!input.evaluation_feedback;\n\n// Calculate the CORRECT attempt number:\n// - evaluation_history.length = number of completed attempts\n// - If we have evaluation_result but it's not in history yet, add 1\n// - The current attempt is history.length + 1\n\nlet completedAttempts = existingHistory.length;\n\n// If we have evaluation_result but history is empty, we've completed 1 attempt\nif (hasEvaluationResult && completedAttempts === 0) {\n  completedAttempts = 1;\n}\n\n// Current attempt is completedAttempts + 1\nconst currentAttempt = completedAttempts + 1;\n\n// For If2 condition compatibility: attempt_number should be the NUMBER OF COMPLETED attempts\n// If2 checks: attempt_number < max_attempts\n// So if max_attempts = 3:\n//   - After attempt 1 fails: attempt_number should be 1, 1 < 3 = true → retry\n//   - After attempt 2 fails: attempt_number should be 2, 2 < 3 = true → retry  \n//   - After attempt 3 fails: attempt_number should be 3, 3 < 3 = false → stop\nconst attemptNumberForIf2 = completedAttempts;\n\nconst maxAttempts = input.loopContext?.max_attempts || 3;\n\n// ============================================================================\n// DETERMINE IF THIS IS A RETRY\n// ============================================================================\n\nconst evaluationResult = input.evaluation_result || null;\nconst existingFeedback = input.evaluation_feedback || null;\n\n// It's a retry if we have evaluation results\nconst isRetry = hasEvaluationResult || hasEvaluationFeedback;\n\nconsole.log(`[Loop] ========================================`);\nconsole.log(`[Loop] ATTEMPT CALCULATION:`);\nconsole.log(`[Loop]   - evaluation_history.length: ${existingHistory.length}`);\nconsole.log(`[Loop]   - has evaluation_result: ${hasEvaluationResult}`);\nconsole.log(`[Loop]   - completedAttempts: ${completedAttempts}`);\nconsole.log(`[Loop]   - currentAttempt: ${currentAttempt}`);\nconsole.log(`[Loop]   - attemptNumberForIf2: ${attemptNumberForIf2}`);\nconsole.log(`[Loop]   - Is retry: ${isRetry}`);\nconsole.log(`[Loop]   - Will If2 allow retry? ${attemptNumberForIf2} < ${maxAttempts} = ${attemptNumberForIf2 < maxAttempts}`);\nconsole.log(`[Loop] ========================================`);\n\n// ============================================================================\n// BUILD EVALUATION FEEDBACK OBJECT FOR PROMPT BUILDERS\n// ============================================================================\n\nlet evaluationFeedback = null;\n\nif (isRetry && evaluationResult) {\n  evaluationFeedback = {\n    overall_pass: evaluationResult.overall_pass || false,\n    overall_score: evaluationResult.overall_score || null,\n    agent_evaluations: evaluationResult.agent_evaluations || {},\n    regeneration_required: evaluationResult.regeneration_required || {\n      evidence_synthesizer: true,\n      adaptation_strategist: true,\n      narrative_intelligence: true\n    },\n    cross_agent_consistency: evaluationResult.cross_agent_consistency || {},\n    hallucination_check: evaluationResult.hallucination_check || {},\n    ground_truth_alignment: evaluationResult.ground_truth_alignment || {},\n    summary: evaluationResult.summary || {}\n  };\n} else if (isRetry && existingFeedback) {\n  // Use pre-structured feedback\n  evaluationFeedback = {\n    overall_pass: input._evaluation_pass || false,\n    overall_score: input._evaluation_score || null,\n    agent_evaluations: {\n      evidence_synthesizer: {\n        improvement_feedback: existingFeedback.evidence_feedback,\n        critical_issues: []\n      },\n      adaptation_strategist: {\n        improvement_feedback: existingFeedback.strategy_feedback,\n        critical_issues: []\n      },\n      narrative_intelligence: {\n        improvement_feedback: existingFeedback.narrative_feedback,\n        critical_issues: []\n      }\n    },\n    regeneration_required: {\n      evidence_synthesizer: true,\n      adaptation_strategist: true,\n      narrative_intelligence: true\n    },\n    cross_agent_consistency: {\n      issues: existingFeedback.cross_agent_issues || []\n    },\n    hallucination_check: {\n      instances: existingFeedback.hallucinations || []\n    },\n    summary: {}\n  };\n}\n\n// ============================================================================\n// BUILD LOOP CONTEXT (FIXED!)\n// ============================================================================\n\n// Add new history entry if this is a retry\nconst newHistoryEntry = isRetry && evaluationResult ? [{\n  attempt: completedAttempts,\n  overall_score: evaluationResult.overall_score,\n  overall_pass: evaluationResult.overall_pass,\n  agent_scores: {\n    evidence_synthesizer: evaluationResult.agent_evaluations?.evidence_synthesizer?.score,\n    adaptation_strategist: evaluationResult.agent_evaluations?.adaptation_strategist?.score,\n    narrative_intelligence: evaluationResult.agent_evaluations?.narrative_intelligence?.score\n  },\n  recommendation: evaluationResult.summary?.recommendation,\n  timestamp: new Date().toISOString()\n}] : [];\n\n// Only add to history if not already there (avoid duplicates)\nconst updatedHistory = newHistoryEntry.length > 0 && \n                       existingHistory.length < completedAttempts\n                       ? [...existingHistory, ...newHistoryEntry]\n                       : existingHistory;\n\nconst loopContext = {\n  // CRITICAL FIX: This is what If2 checks!\n  // attempt_number = number of COMPLETED attempts\n  attempt_number: attemptNumberForIf2,\n  max_attempts: maxAttempts,\n  is_retry: isRetry,\n  \n  // Evaluation history (source of truth)\n  evaluation_history: updatedHistory,\n  \n  // Last evaluation\n  last_evaluation: evaluationResult,\n  \n  // Approval status\n  approved: evaluationResult?.overall_pass || false,\n  \n  // Previous outputs\n  previous_outputs: isRetry ? {\n    evidence_synthesis: input.evidence_synthesis || null,\n    adaptation_strategy: input.adaptation_strategy || null,\n    stakeholder_narratives: input.stakeholder_narratives || null\n  } : null\n};\n\n// ============================================================================\n// SAFETY CHECK\n// ============================================================================\n\nif (currentAttempt > maxAttempts) {\n  console.error(`[Loop] ERROR: Attempt ${currentAttempt} exceeds max_attempts ${maxAttempts}!`);\n  console.error(`[Loop] This should have been caught by If2. Check If2 condition.`);\n}\n\n// ============================================================================\n// OUTPUT\n// ============================================================================\n\n// Clear previous agent outputs if this is a retry\nconst outputBase = isRetry ? {\n  ...input,\n  evidence_synthesis: null,\n  adaptation_strategy: null,\n  stakeholder_narratives: null\n} : input;\n\nreturn {\n  ...outputBase,\n  \n  // Primary feedback fields (used by prompt builders)\n  agent_attempt: currentAttempt,\n  max_attempts: maxAttempts,\n  evaluation_feedback: evaluationFeedback,\n  previous_feedback: evaluationFeedback,\n  \n  // Loop context (FIXED - attempt_number now increments correctly)\n  loopContext: loopContext,\n  \n  // Metadata for debugging\n  _loop_status: {\n    current_attempt: currentAttempt,\n    completed_attempts: completedAttempts,\n    attempt_number_for_if2: attemptNumberForIf2,\n    max_attempts: maxAttempts,\n    will_if2_allow_retry: attemptNumberForIf2 < maxAttempts,\n    is_retry: isRetry,\n    history_length: updatedHistory.length,\n    has_evaluation_result: hasEvaluationResult,\n    previous_score: evaluationResult?.overall_score || null\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8736,
        1408
      ],
      "id": "c2ce1bc5-db24-439b-8882-8afa9dc56d7a",
      "name": "initialise counter"
    },
    {
      "parameters": {
        "jsCode": "/**\n * UNIFIED EVALUATOR: Multi-Agent Quality Assessment\n * \n * PURPOSE:\n * Evaluates the outputs of all three agents (Evidence Synthesizer, Adaptation\n * Strategist, Narrative Intelligence) against quality criteria. Determines if\n * outputs meet threshold or require regeneration.\n * \n * POSITION IN PIPELINE:\n * After: All three agents have produced output\n * Decision: Pass to final assembly OR loop back for regeneration\n * \n * INPUTS:\n * - $json.evidence_synthesis (from Agent 1)\n * - $json.adaptation_strategy (from Agent 2)\n * - $json.stakeholder_narratives (from Agent 3)\n * - $json.nature_dependency (ground truth for validation)\n * - $json.tnfd_scenario_frame (ground truth for validation)\n * \n * OUTPUTS:\n * - evaluation_result: Comprehensive quality assessment with pass/fail\n * \n * MODE: Single execution (calls OpenAI API)\n */\n\n// ============================================================================\n// SYSTEM PROMPT\n// ============================================================================\n\nconst EVALUATOR_SYSTEM_PROMPT = `You are a Quality Evaluator for a nature-risk analysis system. Your role is to critically assess the outputs of three AI agents and determine if they meet quality thresholds.\n\n## YOUR TASK\n\nEvaluate three agent outputs:\n1. **Evidence Synthesizer** - Did it properly ground pathways in retrieved evidence?\n2. **Adaptation Strategist** - Are the strategies specific, actionable, and appropriate?\n3. **Narrative Intelligence** - Are the narratives audience-appropriate and accurate?\n\n## EVALUATION CRITERIA\n\n### Evidence Synthesizer (Agent 1)\n| Criterion | Weight | Description |\n|-----------|--------|-------------|\n| Groundedness | 30% | Are claims supported by the retrieved chunks? No fabricated sources? |\n| Completeness | 25% | Are all critical dependencies addressed? |\n| Accuracy | 25% | Are quotes and references accurate? No misattributions? |\n| Gap Honesty | 20% | Are evidence gaps acknowledged rather than papered over? |\n\n### Adaptation Strategist (Agent 2)\n| Criterion | Weight | Description |\n|-----------|--------|-------------|\n| Specificity | 30% | Are actions concrete and implementable, not vague platitudes? |\n| Feasibility | 25% | Are recommendations realistic for the sector and context? |\n| Sequencing | 20% | Do short/medium/long term actions build logically? |\n| Cost Realism | 15% | Are cost estimates plausible? Uncertainty acknowledged? |\n| Pathway Alignment | 10% | Do strategies address the identified pathways? |\n\n### Narrative Intelligence (Agent 3)\n| Criterion | Weight | Description |\n|-----------|--------|-------------|\n| Audience Fit | 30% | Is each narrative truly tailored to its audience? |\n| Factual Accuracy | 25% | Do narratives accurately reflect the underlying analysis? |\n| Actionability | 20% | Does each narrative end with appropriate next steps? |\n| Tone Calibration | 15% | Is the tone appropriate for each audience? |\n| Disclosure Readiness | 10% | Is the sustainability section usable in a real report? |\n\n## OUTPUT FORMAT\n\nYou MUST respond with valid JSON:\n\n{\n  \"evaluation_result\": {\n    \"evaluation_timestamp\": \"ISO datetime\",\n    \"overall_pass\": true | false,\n    \"overall_score\": 0-100,\n    \"regeneration_required\": {\n      \"evidence_synthesizer\": true | false,\n      \"adaptation_strategist\": true | false,\n      \"narrative_intelligence\": true | false\n    },\n    \n    \"agent_evaluations\": {\n      \"evidence_synthesizer\": {\n        \"score\": 0-100,\n        \"pass\": true | false,\n        \"threshold\": 75,\n        \"criteria_scores\": {\n          \"groundedness\": { \"score\": 0-100, \"weight\": 0.30, \"notes\": \"string\" },\n          \"completeness\": { \"score\": 0-100, \"weight\": 0.25, \"notes\": \"string\" },\n          \"accuracy\": { \"score\": 0-100, \"weight\": 0.25, \"notes\": \"string\" },\n          \"gap_honesty\": { \"score\": 0-100, \"weight\": 0.20, \"notes\": \"string\" }\n        },\n        \"strengths\": [\"string\"],\n        \"critical_issues\": [\"string\"],\n        \"improvement_feedback\": \"string (specific guidance for regeneration)\"\n      },\n      \n      \"adaptation_strategist\": {\n        \"score\": 0-100,\n        \"pass\": true | false,\n        \"threshold\": 75,\n        \"criteria_scores\": {\n          \"specificity\": { \"score\": 0-100, \"weight\": 0.30, \"notes\": \"string\" },\n          \"feasibility\": { \"score\": 0-100, \"weight\": 0.25, \"notes\": \"string\" },\n          \"sequencing\": { \"score\": 0-100, \"weight\": 0.20, \"notes\": \"string\" },\n          \"cost_realism\": { \"score\": 0-100, \"weight\": 0.15, \"notes\": \"string\" },\n          \"pathway_alignment\": { \"score\": 0-100, \"weight\": 0.10, \"notes\": \"string\" }\n        },\n        \"strengths\": [\"string\"],\n        \"critical_issues\": [\"string\"],\n        \"improvement_feedback\": \"string\"\n      },\n      \n      \"narrative_intelligence\": {\n        \"score\": 0-100,\n        \"pass\": true | false,\n        \"threshold\": 75,\n        \"criteria_scores\": {\n          \"audience_fit\": { \"score\": 0-100, \"weight\": 0.30, \"notes\": \"string\" },\n          \"factual_accuracy\": { \"score\": 0-100, \"weight\": 0.25, \"notes\": \"string\" },\n          \"actionability\": { \"score\": 0-100, \"weight\": 0.20, \"notes\": \"string\" },\n          \"tone_calibration\": { \"score\": 0-100, \"weight\": 0.15, \"notes\": \"string\" },\n          \"disclosure_readiness\": { \"score\": 0-100, \"weight\": 0.10, \"notes\": \"string\" }\n        },\n        \"strengths\": [\"string\"],\n        \"critical_issues\": [\"string\"],\n        \"improvement_feedback\": \"string\"\n      }\n    },\n    \n    \"cross_agent_consistency\": {\n      \"score\": 0-100,\n      \"issues\": [\"string (inconsistencies between agent outputs)\"],\n      \"notes\": \"string\"\n    },\n    \n    \"hallucination_check\": {\n      \"hallucinations_detected\": true | false,\n      \"instances\": [\n        {\n          \"agent\": \"string\",\n          \"claim\": \"string\",\n          \"issue\": \"string (why this is a hallucination)\",\n          \"severity\": \"Critical | Major | Minor\"\n        }\n      ]\n    },\n    \n    \"ground_truth_alignment\": {\n      \"dependencies_addressed\": \"X of Y critical dependencies covered\",\n      \"scenario_consistency\": \"string (do outputs align with selected scenario?)\",\n      \"financial_consistency\": \"string (do narratives match financial figures?)\"\n    },\n    \n    \"summary\": {\n      \"verdict\": \"string (1-2 sentence overall assessment)\",\n      \"primary_strength\": \"string\",\n      \"primary_concern\": \"string\",\n      \"recommendation\": \"Approve | Regenerate Agent 1 | Regenerate Agent 2 | Regenerate Agent 3 | Regenerate All\"\n    }\n  }\n}\n\n## EVALUATION STANDARDS\n\n### Score Interpretation\n- 90-100: Excellent - Production ready\n- 80-89: Good - Minor improvements possible but acceptable\n- 75-79: Acceptable - Meets minimum threshold\n- 60-74: Below threshold - Regeneration recommended\n- Below 60: Poor - Regeneration required\n\n### Pass Threshold\nEach agent must score ≥75 to pass. Overall pass requires all three agents to pass AND cross-agent consistency ≥70.\n\n### Hallucination Detection\nFlag as hallucination if:\n- A source is cited that wasn't in retrieved chunks\n- A statistic is quoted without source\n- A company/case study is mentioned that wasn't in the evidence\n- A strategy references capabilities the asset doesn't have\n- A narrative contradicts the underlying data\n\n### Critical Issues (Auto-Fail)\nAny of these results in automatic fail for that agent:\n- Fabricated sources or citations\n- Financial figures that don't match input data\n- Strategies that contradict the scenario (e.g., \"business as usual\" in \"Go fast or go home\")\n- Narratives that downplay Critical/High risks\n\n## TONE\n\nBe rigorous but constructive. The goal is quality assurance, not criticism. Provide specific, actionable feedback that would help regeneration succeed.`;\n\n// ============================================================================\n// USER PROMPT BUILDER\n// ============================================================================\n\nfunction buildEvaluatorPrompt(data) {\n  const nd = data.nature_dependency || {};\n  const frame = data.tnfd_scenario_frame || {};\n  const evidence = data.evidence_synthesis || {};\n  const strategy = data.adaptation_strategy || {};\n  const narratives = data.stakeholder_narratives || {};\n  const financial = data.financial_impact || data.shock_grid || {};\n  \n  // Ground truth summary\n  const criticalDeps = (nd.dependencies || [])\n    .filter(d => d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\");\n  \n  const groundTruth = `\n## GROUND TRUTH (for validation)\n\n### Critical Dependencies (must be addressed)\n${criticalDeps.map(d => `- ${d.ecosystem_service} (${d.dependency_strength}): ${d.rationale}`).join('\\n')}\n\n### Selected Scenario\n- Name: ${frame.scenario?.scenario_name || 'Unknown'}\n- Physical Score: ${frame.axes?.ecosystem_service_degradation?.toFixed(2) || 'N/A'}\n- Transition Score: ${frame.axes?.market_nonmarket_alignment?.toFixed(2) || 'N/A'}\n- Risk Posture: ${frame.scenario_detail?.risk_posture || 'Unknown'}\n\n### Financial Figures (must be consistent)\n- Total Exposure: €${(financial.severe_total_eur || financial.total_exposure || 0).toLocaleString()}\n- OPEX: €${(financial.opex_eur || 0).toLocaleString()}\n- CAPEX: €${(financial.capex_eur || 0).toLocaleString()}\n- Asset Value: €${(nd.value_eur || data.asset?.value_eur || 0).toLocaleString()}\n`;\n\n  // Format agent outputs for evaluation\n  const evidenceOutput = JSON.stringify(evidence, null, 2).substring(0, 4000);\n  const strategyOutput = JSON.stringify(strategy, null, 2).substring(0, 4000);\n  const narrativesOutput = JSON.stringify(narratives, null, 2).substring(0, 4000);\n\n  return `${groundTruth}\n\n---\n\n## AGENT 1 OUTPUT: Evidence Synthesizer\n\n\\`\\`\\`json\n${evidenceOutput}${evidence && JSON.stringify(evidence).length > 4000 ? '\\n... (truncated)' : ''}\n\\`\\`\\`\n\n---\n\n## AGENT 2 OUTPUT: Adaptation Strategist\n\n\\`\\`\\`json\n${strategyOutput}${strategy && JSON.stringify(strategy).length > 4000 ? '\\n... (truncated)' : ''}\n\\`\\`\\`\n\n---\n\n## AGENT 3 OUTPUT: Narrative Intelligence\n\n\\`\\`\\`json\n${narrativesOutput}${narratives && JSON.stringify(narratives).length > 4000 ? '\\n... (truncated)' : ''}\n\\`\\`\\`\n\n---\n\n## YOUR TASK\n\nEvaluate all three agent outputs against:\n1. Their individual quality criteria\n2. Consistency with ground truth\n3. Cross-agent consistency\n4. Hallucination detection\n\nDetermine if each agent passes (≥75) and whether regeneration is needed.\n\nRespond with valid JSON only.`;\n}\n\n// ============================================================================\n// MAIN EXECUTION (for n8n Code node)\n// ============================================================================\n\n// Build the prompt\nconst userPrompt = buildEvaluatorPrompt($json);\n\n// Return for use in OpenAI node\nreturn {\n  ...$json,\n  evaluator_prompt: {\n    system: EVALUATOR_SYSTEM_PROMPT,\n    user: userPrompt\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        11536,
        1552
      ],
      "id": "80d15ecc-9dd7-459c-8087-e26cc6de403a",
      "name": "Build Evaluator Prompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.evaluator_prompt.user }}",
        "messages": {
          "messageValues": [
            {
              "message": "={{ $json.evaluator_prompt.system }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.8,
      "position": [
        11760,
        1552
      ],
      "id": "75a7dd63-643b-4cab-9a4d-4f06deb95279",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 3000,
          "temperature": 0.2
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        11840,
        1776
      ],
      "id": "285bbbdd-57d8-4cc1-b2b4-91f5473598b9",
      "name": "OpenAI Chat Model4",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Parse Evaluation Output\n * \n * PURPOSE:\n * Parses the JSON response from the Unified Evaluator\n * Handles various response formats including markdown code fences\n * Routes based on pass/fail status\n * \n * HANDLES:\n * - Raw JSON: {\"evaluation_result\": {...}}\n * - Markdown fenced: ```json\\n{...}\\n```\n * - With output wrapper: {\"output\": \"```json\\n{...}\\n```\"}\n * - Array wrapper: [{\"output\": \"...\"}]\n */\n\n// Get the raw response - handle different input structures\nlet rawResponse = $json;\n\n// If it's an array, get first element\nif (Array.isArray(rawResponse)) {\n  rawResponse = rawResponse[0];\n}\n\n// If there's an \"output\" field (common n8n AI node pattern), use that\nlet responseText = rawResponse.text || \n                   rawResponse.message?.content || \n                   rawResponse.text ||\n                   rawResponse.response ||\n                   (typeof rawResponse === 'string' ? rawResponse : JSON.stringify(rawResponse));\n\n// If responseText is still an object with nested output, extract it\nif (typeof responseText === 'object' && responseText.text) {\n  responseText = responseText.text;\n}\n\n// Ensure we have a string to work with\nif (typeof responseText !== 'string') {\n  responseText = JSON.stringify(responseText);\n}\n\nlet evaluation_result = null;\nlet parseError = null;\n\ntry {\n  // Step 1: Try direct JSON parse (in case it's clean JSON)\n  evaluation_result = JSON.parse(responseText);\n} catch (e1) {\n  try {\n    // Step 2: Try extracting from markdown code fence\n    const codeBlockMatch = responseText.match(/```(?:json)?\\s*\\n?([\\s\\S]*?)\\n?```/);\n    \n    if (codeBlockMatch && codeBlockMatch[1]) {\n      const extracted = codeBlockMatch[1].trim();\n      evaluation_result = JSON.parse(extracted);\n    } else {\n      // Step 3: Try finding JSON object directly (starts with { ends with })\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        evaluation_result = JSON.parse(jsonMatch[0]);\n      } else {\n        throw new Error(\"No JSON structure found in response\");\n      }\n    }\n  } catch (e2) {\n    parseError = `Parse failed: ${e2.message}. First 500 chars: ${responseText.substring(0, 500)}`;\n  }\n}\n\n// Extract the evaluation_result object if it's nested\nif (evaluation_result && evaluation_result.evaluation_result) {\n  evaluation_result = evaluation_result.evaluation_result;\n}\n\n// Get the previous node's data to merge\n// Adjust the node name to match your actual node name\nconst previousData = $('Build Evaluator Prompt').item?.json || \n                     $('Unified Evaluator').item?.json ||\n                     $json || {};\n\n// Determine pass/fail status\nlet overallPass = false;\nlet overallScore = 0;\n\nif (evaluation_result && !parseError) {\n  overallPass = evaluation_result.overall_pass === true;\n  overallScore = evaluation_result.overall_score || 0;\n}\n\n// Build output\nif (evaluation_result && !parseError) {\n  return {\n    ...previousData,\n    evaluation_result: evaluation_result,\n    _parse_status: \"success\",\n    _evaluation_pass: overallPass,\n    _evaluation_score: overallScore,\n    // These fields help with IF node routing\n    evaluation_passed: overallPass,\n    should_regenerate: !overallPass\n  };\n} else {\n  // Parse failed - treat as failed evaluation to trigger regeneration or exit\n  return {\n    ...previousData,\n    evaluation_result: {\n      error: parseError || \"Unknown parse error\",\n      raw_response_preview: responseText.substring(0, 1000),\n      overall_pass: false,\n      overall_score: 0,\n      summary: {\n        verdict: \"Evaluation parsing failed\",\n        recommendation: \"Review evaluator output format\"\n      }\n    },\n    _parse_status: \"failed\",\n    _parse_error: parseError,\n    _evaluation_pass: false,\n    _evaluation_score: 0,\n    evaluation_passed: false,\n    should_regenerate: false // Don't regenerate on parse failure, exit gracefully\n  };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12160,
        1552
      ],
      "id": "5f277483-0061-4cc0-9188-fd7612d10d0e",
      "name": "Parse Evaluation Output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build the complete output package\n    const output = {\n      // Metadata\n      analysis_id: `TNFD-${Date.now()}`,\n      generated_at: new Date().toISOString(),\n      version: \"2.0.0\",\n      \n      // Input context\n      asset: $json.asset,\n      \n      // Deterministic analysis\n      nature_dependency: $json.nature_dependency,\n      tnfd_scenario_frame: $json.tnfd_scenario_frame,\n      financial_impact: $json.financial_impact || $json.shock_grid,\n      \n      // AI-generated content\n      evidence_synthesis: $json.evidence_synthesis,\n      adaptation_strategy: $json.adaptation_strategy,\n      stakeholder_narratives: $json.stakeholder_narratives,\n      \n      // Quality assurance\n      evaluation_result: $json.evaluation_result,\n      generation_attempts: $json.agent_attempt,\n      \n      // Explainability\n      explainability_pack: {\n        rag_strategy: $json.rag_strategy,\n        rag_queries_used: $json.rag_queries,\n        chunks_retrieved: ($json.retrieved_chunks || []).length,\n        dependency_derivation: $json.nature_dependency?.derivation,\n        scenario_methodology: $json.tnfd_scenario_frame?.methodology,\n        evaluation_methodology: \"Multi-agent unified evaluation with hallucination detection\"\n      }\n    };\n    \n    return output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        12816,
        1552
      ],
      "id": "97262d55-a598-4119-8335-5acc2ec71355",
      "name": "Final Output"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * NF Loop: Financial Impact Engine (v2.0)\n * \n * PURPOSE:\n * Translates shock severity into financial impact estimates using transmission\n * channel modeling with confidence intervals and methodology transparency.\n * \n * KEY IMPROVEMENTS:\n * - Transmission channels aligned to dependency types (Operational Critical, Revenue Critical, etc.)\n * - Confidence intervals (low/mid/high) instead of point estimates\n * - Sector-specific calibration parameters\n * - Non-linear tipping point modeling\n * - Integration with substitutability/time-to-failure\n * - Full methodology traceability\n * \n * INPUTS:\n * - $json.shock_grid (from Shock Grid v2.0)\n * - $json.shock_summary\n * - $json.nature_dependency\n * - $json.tnfd_scenario_frame\n * - $json.asset\n * \n * OUTPUTS:\n * - financial_impact: Structured financial exposure by pathway and tier\n * \n * MODE: runOnceForEachItem\n */\n\nconst fail = (msg) => { throw new Error(`FINANCIAL ENGINE FAILED: ${msg}`); };\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst CONFIG = {\n  // Tipping point parameters (sigmoid function)\n  // At x0, the curve reaches 50% of max impact; k controls steepness\n  tippingPoint: {\n    k: 10,        // Steepness (higher = sharper threshold)\n    x0: 0.60      // Midpoint (severity level where acceleration begins)\n  },\n  \n  // Base transmission rates as % of asset value\n  // These are calibration parameters - should be adjusted with real data\n  transmissionRates: {\n    // By dependency type\n    dependencyType: {\n      \"Operational Critical\": {\n        opex: { low: 0.05, mid: 0.10, high: 0.18 },\n        capex: { low: 0.03, mid: 0.07, high: 0.12 },\n        revenue: { low: 0.02, mid: 0.05, high: 0.10 },\n        downtime_days: { low: 10, mid: 25, high: 45 }\n      },\n      \"Revenue Critical\": {\n        opex: { low: 0.03, mid: 0.06, high: 0.10 },\n        capex: { low: 0.02, mid: 0.04, high: 0.08 },\n        revenue: { low: 0.05, mid: 0.12, high: 0.22 },\n        downtime_days: { low: 5, mid: 15, high: 30 }\n      },\n      \"Compliance\": {\n        opex: { low: 0.04, mid: 0.08, high: 0.14 },\n        capex: { low: 0.05, mid: 0.10, high: 0.18 },\n        revenue: { low: 0.01, mid: 0.03, high: 0.06 },\n        downtime_days: { low: 2, mid: 8, high: 20 }\n      },\n      \"Operational\": {\n        opex: { low: 0.03, mid: 0.06, high: 0.10 },\n        capex: { low: 0.02, mid: 0.05, high: 0.08 },\n        revenue: { low: 0.01, mid: 0.03, high: 0.06 },\n        downtime_days: { low: 3, mid: 10, high: 20 }\n      },\n      \"Reputational\": {\n        opex: { low: 0.01, mid: 0.02, high: 0.04 },\n        capex: { low: 0.01, mid: 0.02, high: 0.04 },\n        revenue: { low: 0.02, mid: 0.05, high: 0.10 },\n        downtime_days: { low: 0, mid: 2, high: 5 }\n      },\n      \"default\": {\n        opex: { low: 0.03, mid: 0.07, high: 0.12 },\n        capex: { low: 0.02, mid: 0.05, high: 0.09 },\n        revenue: { low: 0.02, mid: 0.04, high: 0.08 },\n        downtime_days: { low: 5, mid: 15, high: 30 }\n      }\n    }\n  },\n  \n  // Sector-specific multipliers (based on nature dependency intensity)\n  sectorMultipliers: {\n    \"mining\": 1.25,\n    \"food_agriculture\": 1.30,\n    \"energy\": 1.15,\n    \"tourism\": 1.20,\n    \"pharmaceuticals\": 1.10,\n    \"textiles\": 1.15,\n    \"manufacturing\": 1.00,\n    \"real_estate\": 0.90,\n    \"transportation\": 1.05,\n    \"financial\": 0.60,\n    \"default\": 1.00\n  },\n  \n  // Substitutability adjusts impact (high substitutability = lower impact)\n  substitutabilityMultiplier: {\n    \"Low\": 1.20,      // No alternatives, full impact\n    \"Medium\": 1.00,\n    \"High\": 0.70      // Can substitute, reduced impact\n  },\n  \n  // Time to failure adjusts urgency (short = more immediate)\n  timeToFailureMultiplier: {\n    \"Short\": 1.15,    // Immediate\n    \"Medium\": 1.00,\n    \"Long\": 0.80      // Time to adapt\n  },\n  \n  // Scenario adjusts overall exposure\n  scenarioMultipliers: {\n    \"Go fast or go home\": 1.15,\n    \"Sand in the gears\": 1.25,\n    \"Ahead of the game\": 0.85,\n    \"Back of the list\": 0.90\n  },\n  \n  // Confidence level descriptions\n  confidenceLevels: {\n    high: \"Based on sector benchmarks with empirical validation\",\n    medium: \"Based on sector averages with limited validation\",\n    low: \"Based on generic estimates; significant uncertainty\"\n  }\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nconst clamp01 = (x) => Math.max(0, Math.min(1, x));\n\nconst safeGet = (obj, path, def) => {\n  try {\n    return path.split('.').reduce((a, k) => a?.[k], obj) ?? def;\n  } catch { return def; }\n};\n\n/**\n * Sigmoid function for non-linear tipping point modeling\n * Returns value between 0 and 1\n */\nfunction sigmoid(severity) {\n  const { k, x0 } = CONFIG.tippingPoint;\n  return 1 / (1 + Math.exp(-k * (severity - x0)));\n}\n\n/**\n * Get sector multiplier from matched sectors\n */\nfunction getSectorMultiplier(matchedSectors) {\n  if (!matchedSectors || matchedSectors.length === 0) return CONFIG.sectorMultipliers.default;\n  \n  // Use highest multiplier among matched sectors\n  const multipliers = matchedSectors.map(s => CONFIG.sectorMultipliers[s] || CONFIG.sectorMultipliers.default);\n  return Math.max(...multipliers);\n}\n\n/**\n * Calculate financial impact for a single shock pathway\n */\nfunction calculatePathwayImpact(shockItem, assetValue, sectorMultiplier, scenarioMultiplier) {\n  const depType = shockItem.dependency_type || \"default\";\n  const baseRates = CONFIG.transmissionRates.dependencyType[depType] || \n                    CONFIG.transmissionRates.dependencyType[\"default\"];\n  \n  // Substitutability and time-to-failure adjustments\n  const subMult = CONFIG.substitutabilityMultiplier[shockItem.substitutability] || 1.0;\n  const ttfMult = CONFIG.timeToFailureMultiplier[shockItem.time_to_failure] || 1.0;\n  \n  // Combined adjustment factor\n  const adjustmentFactor = sectorMultiplier * scenarioMultiplier * subMult * ttfMult;\n  \n  // Calculate impacts per tier\n  const tierImpacts = shockItem.tiers.map(tier => {\n    const severity = tier.adjusted_severity || 0;\n    \n    // Apply non-linear tipping point transformation\n    const shockFactor = sigmoid(severity);\n    \n    // Calculate financial line items with ranges\n    const calculateRange = (rates) => ({\n      low: Math.round(assetValue * rates.low * shockFactor * adjustmentFactor),\n      mid: Math.round(assetValue * rates.mid * shockFactor * adjustmentFactor),\n      high: Math.round(assetValue * rates.high * shockFactor * adjustmentFactor)\n    });\n    \n    const opex = calculateRange(baseRates.opex);\n    const capex = calculateRange(baseRates.capex);\n    const revenue = calculateRange(baseRates.revenue);\n    \n    const downtimeRange = {\n      low: Math.round(baseRates.downtime_days.low * shockFactor * adjustmentFactor),\n      mid: Math.round(baseRates.downtime_days.mid * shockFactor * adjustmentFactor),\n      high: Math.round(baseRates.downtime_days.high * shockFactor * adjustmentFactor)\n    };\n    \n    // Total exposure range\n    const total = {\n      low: opex.low + capex.low + revenue.low,\n      mid: opex.mid + capex.mid + revenue.mid,\n      high: opex.high + capex.high + revenue.high\n    };\n    \n    return {\n      tier_id: tier.tier_id,\n      tier_label: tier.tier_label,\n      horizon_year: tier.horizon_year,\n      \n      // Input severity\n      severity_input: severity,\n      shock_factor_applied: Number(shockFactor.toFixed(4)),\n      adjustment_factor: Number(adjustmentFactor.toFixed(4)),\n      \n      // Financial impacts with ranges\n      currency: \"EUR\",\n      impacts: {\n        opex_eur: opex,\n        capex_eur: capex,\n        revenue_loss_eur: revenue,\n        total_exposure_eur: total,\n        downtime_days: downtimeRange\n      },\n      \n      // Single \"best estimate\" for backward compatibility\n      impacts_midpoint: {\n        opex_eur: opex.mid,\n        capex_eur: capex.mid,\n        revenue_loss_eur: revenue.mid,\n        total_eur: total.mid,\n        downtime_days: downtimeRange.mid\n      },\n      \n      // Methodology transparency\n      calculation_basis: {\n        dependency_type: depType,\n        base_rates_used: baseRates,\n        substitutability: shockItem.substitutability,\n        time_to_failure: shockItem.time_to_failure,\n        sector_multiplier: sectorMultiplier,\n        scenario_multiplier: scenarioMultiplier\n      }\n    };\n  });\n  \n  return {\n    ecosystem_service: shockItem.ecosystem_service,\n    ecosystem_service_id: shockItem.ecosystem_service_id,\n    category: shockItem.category,\n    dependency_strength: shockItem.dependency_strength,\n    dependency_type: shockItem.dependency_type,\n    confidence: shockItem.confidence,\n    tier_impacts: tierImpacts\n  };\n}\n\n/**\n * Aggregate totals across all pathways for each tier\n */\nfunction aggregateTotals(pathwayImpacts) {\n  const totalsByTier = {};\n  \n  for (const pathway of pathwayImpacts) {\n    for (const tier of pathway.tier_impacts) {\n      const tierId = tier.tier_id;\n      \n      if (!totalsByTier[tierId]) {\n        totalsByTier[tierId] = {\n          tier_id: tierId,\n          tier_label: tier.tier_label,\n          horizon_year: tier.horizon_year,\n          pathway_count: 0,\n          totals: {\n            opex_eur: { low: 0, mid: 0, high: 0 },\n            capex_eur: { low: 0, mid: 0, high: 0 },\n            revenue_loss_eur: { low: 0, mid: 0, high: 0 },\n            total_exposure_eur: { low: 0, mid: 0, high: 0 },\n            downtime_days: { low: 0, mid: 0, high: 0 }\n          },\n          // Backward compatible midpoint totals\n          totals_midpoint: {\n            opex_eur: 0,\n            capex_eur: 0,\n            revenue_loss_eur: 0,\n            total_eur: 0,\n            downtime_days: 0\n          }\n        };\n      }\n      \n      const t = totalsByTier[tierId];\n      t.pathway_count++;\n      \n      // Aggregate ranges\n      for (const metric of ['opex_eur', 'capex_eur', 'revenue_loss_eur', 'total_exposure_eur', 'downtime_days']) {\n        const impact = tier.impacts[metric];\n        if (impact) {\n          // For downtime, take max rather than sum\n          if (metric === 'downtime_days') {\n            t.totals[metric].low = Math.max(t.totals[metric].low, impact.low);\n            t.totals[metric].mid = Math.max(t.totals[metric].mid, impact.mid);\n            t.totals[metric].high = Math.max(t.totals[metric].high, impact.high);\n          } else {\n            t.totals[metric].low += impact.low;\n            t.totals[metric].mid += impact.mid;\n            t.totals[metric].high += impact.high;\n          }\n        }\n      }\n      \n      // Aggregate midpoints\n      t.totals_midpoint.opex_eur += tier.impacts_midpoint.opex_eur;\n      t.totals_midpoint.capex_eur += tier.impacts_midpoint.capex_eur;\n      t.totals_midpoint.revenue_loss_eur += tier.impacts_midpoint.revenue_loss_eur;\n      t.totals_midpoint.total_eur += tier.impacts_midpoint.total_eur;\n      t.totals_midpoint.downtime_days = Math.max(t.totals_midpoint.downtime_days, tier.impacts_midpoint.downtime_days);\n    }\n  }\n  \n  return Object.values(totalsByTier);\n}\n\n// ============================================================================\n// MAIN LOGIC\n// ============================================================================\n\nconst item = $json || {};\nconst asset = item.asset || {};\nconst shockGrid = Array.isArray(item.shock_grid) ? item.shock_grid : [];\nconst shockSummary = item.shock_summary || {};\nconst nd = item.nature_dependency || {};\nconst frame = item.tnfd_scenario_frame || {};\n\nif (shockGrid.length === 0) {\n  fail(\"Missing shock_grid. Ensure Shock Grid node has run.\");\n}\n\n// Get parameters\nconst assetValue = Number(asset.value_eur) || 0;\nif (assetValue <= 0) {\n  fail(\"Asset value (value_eur) is missing or zero.\");\n}\n\nconst matchedSectors = nd.matched_sectors || [];\nconst scenarioName = safeGet(frame, 'scenario.scenario_name', 'Unknown');\nconst horizonYear = frame.horizon_year || shockSummary.horizon_year || 2030;\n\n// Get multipliers\nconst sectorMultiplier = getSectorMultiplier(matchedSectors);\nconst scenarioMultiplier = CONFIG.scenarioMultipliers[scenarioName] || 1.0;\n\n// Calculate pathway impacts\nconst pathwayImpacts = shockGrid.map(shockItem => \n  calculatePathwayImpact(shockItem, assetValue, sectorMultiplier, scenarioMultiplier)\n);\n\n// Aggregate totals by tier\nconst totalsByTier = aggregateTotals(pathwayImpacts);\n\n// Get severe tier for headline\nconst severeTotals = totalsByTier.find(t => t.tier_id === \"severe\");\nconst adverseTotals = totalsByTier.find(t => t.tier_id === \"adverse\");\n\n// Determine overall confidence\nconst confidenceScores = pathwayImpacts.map(p => p.confidence === \"High\" ? 3 : p.confidence === \"Medium\" ? 2 : 1);\nconst avgConfidence = confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length;\nconst overallConfidence = avgConfidence >= 2.5 ? \"High\" : avgConfidence >= 1.5 ? \"Medium\" : \"Low\";\n\n// Identify top drivers (by severe tier mid-point total)\nconst topDrivers = [...pathwayImpacts]\n  .sort((a, b) => {\n    const aTotal = a.tier_impacts.find(t => t.tier_id === \"severe\")?.impacts_midpoint.total_eur || 0;\n    const bTotal = b.tier_impacts.find(t => t.tier_id === \"severe\")?.impacts_midpoint.total_eur || 0;\n    return bTotal - aTotal;\n  })\n  .slice(0, 3)\n  .map(p => ({\n    ecosystem_service: p.ecosystem_service,\n    dependency_strength: p.dependency_strength,\n    severe_total_eur: p.tier_impacts.find(t => t.tier_id === \"severe\")?.impacts_midpoint.total_eur\n  }));\n\n// Build output\nconst financial_impact = {\n  horizon_year: horizonYear,\n  asset_value_eur: assetValue,\n  currency: \"EUR\",\n  \n  // Summary headline\n  headline: {\n    severe_exposure_range: severeTotals ? {\n      low: severeTotals.totals.total_exposure_eur.low,\n      mid: severeTotals.totals.total_exposure_eur.mid,\n      high: severeTotals.totals.total_exposure_eur.high\n    } : null,\n    adverse_exposure_range: adverseTotals ? {\n      low: adverseTotals.totals.total_exposure_eur.low,\n      mid: adverseTotals.totals.total_exposure_eur.mid,\n      high: adverseTotals.totals.total_exposure_eur.high\n    } : null,\n    headline_text: severeTotals ? \n      `Estimated ${horizonYear} exposure (severe): €${severeTotals.totals.total_exposure_eur.low.toLocaleString()} - €${severeTotals.totals.total_exposure_eur.high.toLocaleString()} (mid: €${severeTotals.totals.total_exposure_eur.mid.toLocaleString()})` :\n      \"Financial exposure calculated\"\n  },\n  \n  // Detailed pathway impacts\n  pathway_impacts: pathwayImpacts,\n  \n  // Aggregated totals\n  totals_by_tier: totalsByTier,\n  \n  // Backward compatible single values (using midpoints)\n  severe_total_eur: severeTotals?.totals_midpoint.total_eur || 0,\n  opex_eur: severeTotals?.totals_midpoint.opex_eur || 0,\n  capex_eur: severeTotals?.totals_midpoint.capex_eur || 0,\n  revenue_eur: severeTotals?.totals_midpoint.revenue_loss_eur || 0,\n  \n  // Risk drivers\n  top_drivers: topDrivers,\n  \n  // Confidence and methodology\n  confidence: {\n    overall: overallConfidence,\n    description: CONFIG.confidenceLevels[overallConfidence.toLowerCase()],\n    pathway_confidence_breakdown: pathwayImpacts.map(p => ({\n      ecosystem_service: p.ecosystem_service,\n      confidence: p.confidence\n    }))\n  },\n  \n  methodology: {\n    version: \"2.0.0\",\n    approach: \"Transmission channel modeling with tipping point non-linearity\",\n    tipping_point_parameters: CONFIG.tippingPoint,\n    sector_multiplier_applied: sectorMultiplier,\n    sector_multiplier_source: `Matched sectors: ${matchedSectors.join(', ') || 'default'}`,\n    scenario_multiplier_applied: scenarioMultiplier,\n    scenario_name: scenarioName,\n    calibration_note: \"Transmission rates are sector-generic estimates. Calibrate with actual financial data for production use.\",\n    limitations: [\n      \"Point-in-time analysis; does not model dynamic adaptation\",\n      \"Transmission rates based on sector averages, not company-specific\",\n      \"Does not capture second-order effects (supply chain, regional)\",\n      \"Confidence intervals are symmetric; real distributions may be skewed\"\n    ]\n  }\n};\n\nreturn {\n  ...item,\n  financial_impact\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8272,
        1344
      ],
      "id": "e1c36f85-80e9-4215-b60e-c77c4a6e1cc5",
      "name": "NF Loop: Financial Impact Engine"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * NF Loop: Shock Grid (v2.0)\n * \n * PURPOSE:\n * Generates severity-tiered shock values for each ecosystem service dependency,\n * using the enhanced dependency data from Dependency Mapper v2.0.\n * \n * KEY IMPROVEMENTS:\n * - Uses substitutability and time_to_failure from enhanced dependencies\n * - Expands shock families to cover all 16 ENCORE ecosystem services\n * - Integrates environmental context (water stress, biome sensitivity)\n * - Scenario-specific shock amplification\n * - Confidence scoring for each shock\n * \n * INPUTS:\n * - $json.nature_dependency (from Dependency Mapper v2.0)\n * - $json.tnfd_scenario_frame (from TNFD Axes v2.0)\n * - $json.asset\n * - $json.run_metadata\n * \n * OUTPUTS:\n * - shock_grid: Array of pathway shocks by tier\n * - shock_summary: Aggregated metadata\n * \n * MODE: runOnceForEachItem\n */\n\nconst fail = (msg) => { throw new Error(`SHOCK GRID FAILED: ${msg}`); };\n\n// ============================================================================\n// CONFIGURATION\n// ============================================================================\n\nconst CONFIG = {\n  // Dependency strength multipliers (ENCORE-aligned)\n  dependencyStrength: {\n    \"Very High\": 1.15,\n    \"High\": 1.0,\n    \"Medium\": 0.80,\n    \"Low\": 0.60\n  },\n  \n  // Substitutability affects shock absorption capacity\n  // Low substitutability = higher shock (no alternatives)\n  substitutability: {\n    \"Low\": 1.15,      // No alternatives, full shock transmission\n    \"Medium\": 0.95,\n    \"High\": 0.70      // Can substitute, shock absorbed\n  },\n  \n  // Time to failure affects shock urgency/severity\n  // Short time = higher immediate shock\n  timeToFailure: {\n    \"Short\": 1.10,    // Immediate operational impact\n    \"Medium\": 0.95,\n    \"Long\": 0.80      // Time to adapt\n  },\n  \n  // Scenario-specific shock amplification\n  scenarioMultipliers: {\n    \"Go fast or go home\": { physical: 1.20, transition: 1.10 },\n    \"Sand in the gears\": { physical: 1.25, transition: 0.90 },\n    \"Ahead of the game\": { physical: 0.85, transition: 1.05 },\n    \"Back of the list\": { physical: 0.90, transition: 0.85 }\n  },\n  \n  // Environmental context multipliers\n  waterStressMultiplier: {\n    \"high\": 1.15,\n    \"medium\": 1.0,\n    \"low\": 0.90,\n    \"unknown\": 1.0\n  },\n  \n  biomeSensitivityThresholds: {\n    veryHigh: 1.25,   // factor >= 1.25\n    high: 1.15,       // factor >= 1.15\n    medium: 1.05      // factor >= 1.05\n  },\n  \n  // Shock tiers (base severity before adjustments)\n  tiers: [\n    { id: \"base\",    label: \"Base (Expected)\",     baseSeverity: 0.30 },\n    { id: \"adverse\", label: \"Adverse (Stressed)\",  baseSeverity: 0.55 },\n    { id: \"severe\",  label: \"Severe (Crisis)\",     baseSeverity: 0.80 }\n  ],\n  \n  // Ecosystem service shock families (expanded for all 16 services)\n  serviceShockFamilies: {\n    // Provisioning Services\n    \"Surface Water\": [\n      { family: \"water_availability\", description: \"Freshwater supply reduction\" },\n      { family: \"allocation_restrictions\", description: \"Regulatory limits on abstraction\" },\n      { family: \"input_cost_pressure\", description: \"Increased water procurement costs\" },\n      { family: \"quality_degradation\", description: \"Source water quality decline\" }\n    ],\n    \"Ground Water\": [\n      { family: \"aquifer_depletion\", description: \"Groundwater table decline\" },\n      { family: \"recharge_disruption\", description: \"Reduced natural recharge\" },\n      { family: \"subsidence_risk\", description: \"Ground subsidence from over-extraction\" },\n      { family: \"permit_constraints\", description: \"Abstraction permit restrictions\" }\n    ],\n    \"Fibres & Other Materials\": [\n      { family: \"supply_disruption\", description: \"Raw material availability\" },\n      { family: \"price_volatility\", description: \"Biomass/fibre cost increases\" },\n      { family: \"certification_requirements\", description: \"Sustainable sourcing mandates\" }\n    ],\n    \"Genetic Materials\": [\n      { family: \"bioprospecting_limits\", description: \"Access restrictions to genetic resources\" },\n      { family: \"abs_compliance\", description: \"Nagoya Protocol compliance costs\" },\n      { family: \"species_loss\", description: \"Loss of potentially valuable species\" }\n    ],\n    \n    // Regulating Services\n    \"Climate Regulation\": [\n      { family: \"temperature_extremes\", description: \"Increased cooling/heating demand\" },\n      { family: \"productivity_loss\", description: \"Worker/equipment efficiency decline\" },\n      { family: \"microclimate_degradation\", description: \"Local climate regulation loss\" }\n    ],\n    \"Flood & Storm Protection\": [\n      { family: \"flood_damage\", description: \"Direct asset damage from flooding\" },\n      { family: \"business_interruption\", description: \"Operational shutdown from events\" },\n      { family: \"insurance_cost\", description: \"Premium increases or coverage loss\" },\n      { family: \"buffer_degradation\", description: \"Natural protection loss (wetlands, mangroves)\" }\n    ],\n    \"Water Quality Regulation\": [\n      { family: \"treatment_cost\", description: \"Increased water treatment requirements\" },\n      { family: \"compliance_stringency\", description: \"Tighter discharge permits\" },\n      { family: \"shutdown_risk\", description: \"Operations halt due to contamination\" },\n      { family: \"liability_exposure\", description: \"Pollution liability risk\" }\n    ],\n    \"Soil Quality Regulation\": [\n      { family: \"yield_decline\", description: \"Productivity loss from soil degradation\" },\n      { family: \"input_cost_increase\", description: \"Fertilizer/amendment requirements\" },\n      { family: \"land_value_decline\", description: \"Asset value impairment\" },\n      { family: \"remediation_cost\", description: \"Soil restoration requirements\" }\n    ],\n    \"Pollination\": [\n      { family: \"yield_loss\", description: \"Crop yield reduction from pollinator decline\" },\n      { family: \"hand_pollination_cost\", description: \"Manual pollination requirements\" },\n      { family: \"crop_failure_risk\", description: \"Complete pollination failure events\" }\n    ],\n    \"Pest & Disease Control\": [\n      { family: \"crop_loss\", description: \"Pest/disease damage to production\" },\n      { family: \"pesticide_cost\", description: \"Increased chemical control costs\" },\n      { family: \"resistance_development\", description: \"Pest resistance to controls\" },\n      { family: \"outbreak_risk\", description: \"Major pest/disease outbreak\" }\n    ],\n    \"Erosion Control\": [\n      { family: \"infrastructure_damage\", description: \"Erosion damage to structures\" },\n      { family: \"sedimentation_impact\", description: \"Navigability/intake issues\" },\n      { family: \"land_loss\", description: \"Productive land erosion\" },\n      { family: \"maintenance_cost\", description: \"Increased erosion control maintenance\" }\n    ],\n    \"Mass Stabilisation & Erosion Control\": [\n      { family: \"landslide_risk\", description: \"Slope failure/landslide events\" },\n      { family: \"foundation_damage\", description: \"Structural integrity issues\" },\n      { family: \"access_disruption\", description: \"Route/access closures\" },\n      { family: \"safety_incidents\", description: \"Worker/public safety events\" }\n    ],\n    \"Air Quality Regulation\": [\n      { family: \"health_cost\", description: \"Worker health impacts\" },\n      { family: \"compliance_cost\", description: \"Emissions control requirements\" },\n      { family: \"productivity_impact\", description: \"Reduced output from air quality\" },\n      { family: \"reputation_damage\", description: \"Stakeholder perception issues\" }\n    ],\n    \"Noise Attenuation\": [\n      { family: \"mitigation_cost\", description: \"Noise barrier requirements\" },\n      { family: \"complaint_risk\", description: \"Community complaints/restrictions\" },\n      { family: \"property_impact\", description: \"Adjacent property value effects\" }\n    ],\n    \n    // Cultural Services\n    \"Recreation & Tourism\": [\n      { family: \"visitor_decline\", description: \"Reduced tourist numbers\" },\n      { family: \"destination_degradation\", description: \"Attractiveness decline\" },\n      { family: \"revenue_loss\", description: \"Direct tourism revenue impact\" },\n      { family: \"brand_damage\", description: \"Destination reputation harm\" }\n    ],\n    \"Aesthetic Values\": [\n      { family: \"viewshed_degradation\", description: \"Scenic quality decline\" },\n      { family: \"property_devaluation\", description: \"Asset value from aesthetics\" },\n      { family: \"experience_quality\", description: \"Visitor/occupant satisfaction\" }\n    ]\n  },\n  \n  // Default shock family for unmapped services\n  defaultShockFamily: [\n    { family: \"generic_disruption\", description: \"General ecosystem service disruption\" },\n    { family: \"operational_impact\", description: \"Operations affected by service loss\" },\n    { family: \"cost_increase\", description: \"Increased costs from degradation\" }\n  ]\n};\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nconst clamp01 = (x) => Math.max(0, Math.min(1, x));\n\nconst safeGet = (obj, path, def) => {\n  try {\n    return path.split('.').reduce((a, k) => a?.[k], obj) ?? def;\n  } catch { return def; }\n};\n\n/**\n * Get biome sensitivity category from factor\n */\nfunction getBiomeSensitivityMultiplier(factor) {\n  if (!factor || factor < 1.05) return 1.0;\n  if (factor >= CONFIG.biomeSensitivityThresholds.veryHigh) return 1.15;\n  if (factor >= CONFIG.biomeSensitivityThresholds.high) return 1.10;\n  if (factor >= CONFIG.biomeSensitivityThresholds.medium) return 1.05;\n  return 1.0;\n}\n\n/**\n * Calculate dependency-adjusted severity\n */\nfunction calculateDependencySeverity(dep, envContext, scenarioName) {\n  // Base factors from dependency\n  const strengthFactor = CONFIG.dependencyStrength[dep.dependency_strength] ?? 0.85;\n  const subFactor = CONFIG.substitutability[dep.substitutability] ?? 0.95;\n  const ttfFactor = CONFIG.timeToFailure[dep.time_to_failure] ?? 0.95;\n  \n  // Environmental context\n  const waterStressFactor = CONFIG.waterStressMultiplier[envContext.water_stress_level] ?? 1.0;\n  const biomeFactor = getBiomeSensitivityMultiplier(envContext.biome_sensitivity_factor);\n  \n  // Only apply water stress to water-related services\n  const isWaterRelated = [\"Surface Water\", \"Ground Water\", \"Water Quality Regulation\"].includes(dep.ecosystem_service);\n  const contextFactor = isWaterRelated ? waterStressFactor : 1.0;\n  \n  // Scenario multiplier (physical component)\n  const scenarioMult = CONFIG.scenarioMultipliers[scenarioName]?.physical ?? 1.0;\n  \n  // Combined severity multiplier\n  const combined = strengthFactor * subFactor * ttfFactor * contextFactor * biomeFactor * scenarioMult;\n  \n  return {\n    combined,\n    components: {\n      dependency_strength: strengthFactor,\n      substitutability: subFactor,\n      time_to_failure: ttfFactor,\n      water_stress: isWaterRelated ? waterStressFactor : null,\n      biome_sensitivity: biomeFactor,\n      scenario: scenarioMult\n    }\n  };\n}\n\n/**\n * Build shock grid for a single dependency\n */\nfunction buildShockGridForDependency(dep, envContext, scenarioName, horizonYear, runYear, axes) {\n  const serviceName = dep.ecosystem_service;\n  \n  // Get shock families for this service\n  const shockFamilies = CONFIG.serviceShockFamilies[serviceName] || CONFIG.defaultShockFamily;\n  \n  // Calculate severity multiplier\n  const severityCalc = calculateDependencySeverity(dep, envContext, scenarioName);\n  \n  // Build tiers\n  const tiers = CONFIG.tiers.map(tier => {\n    // Adjusted severity = base tier severity * dependency multiplier\n    const adjustedSeverity = clamp01(tier.baseSeverity * severityCalc.combined);\n    \n    // Build shocks for each family\n    const shocks = shockFamilies.map(family => ({\n      family: family.family,\n      description: family.description,\n      unit: \"severity_index_0_1\",\n      severity_index: Number(adjustedSeverity.toFixed(4)),\n      severity_interpretation: adjustedSeverity >= 0.7 ? \"Critical\" :\n                               adjustedSeverity >= 0.5 ? \"High\" :\n                               adjustedSeverity >= 0.3 ? \"Moderate\" : \"Low\",\n      rationale: {\n        base_tier_severity: tier.baseSeverity,\n        dependency_strength: dep.dependency_strength,\n        substitutability: dep.substitutability,\n        time_to_failure: dep.time_to_failure,\n        severity_components: severityCalc.components\n      }\n    }));\n    \n    return {\n      tier_id: tier.id,\n      tier_label: tier.label,\n      horizon_year: horizonYear,\n      run_year: runYear,\n      adjusted_severity: Number(adjustedSeverity.toFixed(4)),\n      shocks\n    };\n  });\n  \n  // Confidence based on data completeness\n  const confidence = dep.substitutability && dep.time_to_failure ? \"High\" : \n                     dep.dependency_strength ? \"Medium\" : \"Low\";\n  \n  return {\n    ecosystem_service: serviceName,\n    ecosystem_service_id: dep.ecosystem_service_id || serviceName.toLowerCase().replace(/ /g, \"_\"),\n    category: dep.category,\n    dependency_strength: dep.dependency_strength,\n    dependency_type: dep.dependency_type,\n    substitutability: dep.substitutability,\n    time_to_failure: dep.time_to_failure,\n    severity_multiplier: Number(severityCalc.combined.toFixed(4)),\n    confidence,\n    tiers\n  };\n}\n\n// ============================================================================\n// MAIN LOGIC\n// ============================================================================\n\nconst item = $json || {};\nconst asset = item.asset || {};\nconst run = item.run_metadata || {};\nconst frame = item.tnfd_scenario_frame || {};\nconst nd = item.nature_dependency || {};\n\n// Get dependencies\nconst deps = Array.isArray(nd.dependencies) ? nd.dependencies : [];\nif (deps.length === 0) {\n  fail(\"No dependencies found. Ensure Dependency Mapper has run.\");\n}\n\n// Get environmental context\nconst envContext = nd.environmental_context || {};\n\n// Get scenario context\nconst scenarioName = safeGet(frame, 'scenario.scenario_name', 'Unknown');\nconst axes = frame.axes || {};\nconst horizonYear = Number(frame.horizon_year) || 2030;\n\n// Get run year\nconst receivedAt = run.received_at || new Date().toISOString();\nconst runYear = Number(String(receivedAt).slice(0, 4)) || new Date().getFullYear();\n\n// Build shock grid for each dependency\nconst shock_grid = deps.map(dep => \n  buildShockGridForDependency(dep, envContext, scenarioName, horizonYear, runYear, axes)\n);\n\n// Calculate summary statistics\nconst severityStats = {\n  severe_tier: {\n    min: Math.min(...shock_grid.map(s => s.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity || 0)),\n    max: Math.max(...shock_grid.map(s => s.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity || 0)),\n    avg: shock_grid.reduce((sum, s) => sum + (s.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity || 0), 0) / shock_grid.length\n  }\n};\n\n// Identify top risk drivers (highest severe tier severity)\nconst topRiskDrivers = [...shock_grid]\n  .sort((a, b) => {\n    const aSev = a.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity || 0;\n    const bSev = b.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity || 0;\n    return bSev - aSev;\n  })\n  .slice(0, 3)\n  .map(s => ({\n    ecosystem_service: s.ecosystem_service,\n    dependency_strength: s.dependency_strength,\n    severe_severity: s.tiers.find(t => t.tier_id === \"severe\")?.adjusted_severity\n  }));\n\n// Build summary\nconst shock_summary = {\n  run_year: runYear,\n  horizon_year: horizonYear,\n  scenario: frame.scenario || null,\n  axes: {\n    ecosystem_service_degradation: axes.ecosystem_service_degradation,\n    market_nonmarket_alignment: axes.market_nonmarket_alignment\n  },\n  environmental_context: {\n    water_stress: envContext.water_stress_level,\n    biome_sensitivity: envContext.biome_sensitivity_factor,\n    biodiversity_sensitivity: envContext.biodiversity_sensitivity\n  },\n  pathway_count: shock_grid.length,\n  severity_statistics: severityStats,\n  top_risk_drivers: topRiskDrivers,\n  methodology: {\n    version: \"2.0.0\",\n    factors_used: [\"dependency_strength\", \"substitutability\", \"time_to_failure\", \"water_stress\", \"biome_sensitivity\", \"scenario\"],\n    tiers: CONFIG.tiers.map(t => ({ id: t.id, label: t.label, base_severity: t.baseSeverity }))\n  }\n};\n\nreturn {\n  ...item,\n  shock_grid,\n  shock_summary\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8080,
        1344
      ],
      "id": "4d347436-68d5-4a6d-9681-772e78727d74",
      "name": "NF Loop- Shock Grid"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        8464,
        1408
      ],
      "id": "ddf26fcf-8a99-4f7e-920a-00a360b1cde6",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "const testCases = [\n  {\n    name: \"High Impact Agri (Brazil)\",\n    body: [{ asset_id: \"TEST_AGRI_01\", sector: \"Agriculture\", lat: -15.79, lon: -47.88, value_eur: 5000000, country: \"Brazil\"}]\n    \n  },\n  {\n    name: \"Urban Office (London)\",\n    body: [{ asset_id: \"TEST_OFFICE_01\", sector: \"Real Estate\", lat: 51.50, lon: -0.12, value_eur: 20000000 }],\n    scenario: \"Ahead of the game\"\n  },\n  {\n    name: \"Coastal Industrial (Netherlands)\",\n    body: [{ asset_id: \"TEST_IND_01\", sector: \"Manufacturing\", lat: 52.37, lon: 4.89, value_eur: 15000000 }],\n    scenario: \"Go fast or go home\"\n  }\n];\nreturn testCases.map(t => ({ json: t }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        1264
      ],
      "id": "d90d884c-155f-4965-8149-035dcba0ddd4",
      "name": "Test Case Generator"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        3056,
        1264
      ],
      "id": "0dcae0be-88fb-46d1-851e-d5406eb4efe3",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Generate cache key from rounded coordinates\nconst asset = $json.asset || {};\nconst lat = asset.lat;\nconst lon = asset.lon;\n\nif (!lat || !lon) {\n  return { ...$json, cache_status: \"skip\", cache_key: null };\n}\n\nconst roundedLat = Math.round(lat * 100) / 100;\nconst roundedLon = Math.round(lon * 100) / 100;\nconst cacheKey = `${roundedLat}_${roundedLon}`;\n\nreturn {\n  ...$json,\n  cache_key: cacheKey,\n  cache_lookup_needed: true\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5456,
        1616
      ],
      "id": "8b0876e1-6444-4958-988a-933f7272c439",
      "name": "Cache Check"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": ""
        },
        "filtersUI": {
          "values": [
            {
              "lookupColumn": "Cache Key",
              "lookupValue": "={{ $json.cache_key }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        5664,
        1616
      ],
      "id": "5051d20f-e56c-471f-a567-ae6a5a9d62b7",
      "name": "Get row(s) in sheet",
      "alwaysOutputData": true,
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * PROCESS CACHE RESULT - FIXED\n * \n * PROBLEM: Google Sheets returns column headers as field names,\n * which have spaces and different capitalization than what we wrote.\n * \n * What we wrote: cache_key, biome_data, cached_at\n * What Sheets returns: \"Cache Key\", \"Biome Data\", \"Cached At\"\n * \n * SOLUTION: Check for both naming conventions\n */\n\n// ============================================================================\n// NODE: Process Cache Result (FIXED)\n// Position: After Google Sheets Lookup (or after Merge if using that pattern)\n// Mode: Run Once for Each Item\n// ============================================================================\n\nconst CACHE_TTL_HOURS = 24 * 7; // 7 days\n\nfunction isCacheValid(expiresAt) {\n  if (!expiresAt) return false;\n  try {\n    return new Date(expiresAt) > new Date();\n  } catch {\n    return false;\n  }\n}\n\nfunction safeParse(jsonStr) {\n  if (!jsonStr || jsonStr === 'null' || jsonStr === 'undefined') return null;\n  try {\n    return typeof jsonStr === 'string' ? JSON.parse(jsonStr) : jsonStr;\n  } catch (e) {\n    console.log('Parse error:', e.message, 'for:', jsonStr?.substring?.(0, 100));\n    return null;\n  }\n}\n\n// Helper to get field with multiple possible names\nfunction getField(obj, ...possibleNames) {\n  for (const name of possibleNames) {\n    if (obj[name] !== undefined && obj[name] !== null && obj[name] !== '') {\n      return obj[name];\n    }\n  }\n  return null;\n}\n\nconst data = $json;\n\n// ============================================================================\n// GET FIELDS - Handle both snake_case and \"Title Case\" from Sheets\n// ============================================================================\n\nconst cacheKey = getField(data, 'cache_key', 'Cache Key', 'Cache_Key', 'cacheKey');\nconst cachedAt = getField(data, 'cached_at', 'Cached At', 'Cached_At', 'cachedAt');\nconst expiresAt = getField(data, 'expires_at', 'Expires At', 'Expires_At', 'expiresAt');\n\nconst biomeData = getField(data, 'biome_data', 'Biome Data', 'Biome_Data', 'biomeData');\nconst gbifData = getField(data, 'gbif_data', 'Gbif Data', 'GBIF Data', 'Gbif_Data', 'gbifData');\nconst climateData = getField(data, 'climate_data', 'Climate Data', 'Climate_Data', 'climateData');\nconst floodData = getField(data, 'flood_data', 'Flood Data', 'Flood_Data', 'floodData');\nconst climatetraceData = getField(data, 'climatetrace_data', 'Climatetrace Data', 'ClimateTRACE Data', 'Climate Trace Data', 'climatetraceData');\n\n// ============================================================================\n// CHECK CACHE VALIDITY\n// ============================================================================\n\nconst hasCacheData = !!(cachedAt && biomeData);\nconst cacheValid = hasCacheData && isCacheValid(expiresAt);\n\n// Debug logging (remove in production)\nconsole.log('Cache check:', {\n  cacheKey,\n  cachedAt,\n  expiresAt,\n  hasCacheData,\n  cacheValid,\n  biomeDataPresent: !!biomeData,\n  biomeDataType: typeof biomeData\n});\n\nif (cacheValid) {\n  // ============================================================================\n  // CACHE HIT - Restore cached data\n  // ============================================================================\n  \n  const parsedBiome = safeParse(biomeData);\n  const parsedGbif = safeParse(gbifData);\n  const parsedClimate = safeParse(climateData);\n  const parsedFlood = safeParse(floodData);\n  const parsedClimatetrace = safeParse(climatetraceData);\n  \n  return {\n    // Preserve original data\n    run_metadata: data.run_metadata,\n    asset: data.asset,\n    \n    // Cache status\n    cache_status: \"hit\",\n    cache_key: cacheKey,\n    cached_at: cachedAt,\n    \n    // Restored API data - structured for downstream nodes\n    biome: parsedBiome,\n    biodiversity_gbif_iucn: parsedGbif,\n    climate: parsedClimate,\n    flood: parsedFlood,\n    climate_trace: parsedClimatetrace,\n    \n    // Also provide in the format the Merge node would have created\n    // (for compatibility with existing downstream nodes)\n    features: parsedBiome?._raw_features || (parsedBiome?.eco_name ? [{\n      attributes: {\n        eco_name: parsedBiome.eco_name,\n        biome_name: parsedBiome.biome_name,\n        realm: parsedBiome.realm\n      }\n    }] : null),\n    count: parsedGbif?.count || null,\n    facets: parsedGbif?.facets || null,\n    daily: parsedClimate?.daily || null,\n    hourly: parsedClimate?.hourly || null,\n    daily_units: parsedClimate?.daily_units || null,\n    latitude: parsedClimate?.latitude || null,\n    longitude: parsedClimate?.longitude || null,\n    elevation: parsedClimate?.elevation || null,\n    results: parsedClimatetrace?.results || []\n  };\n}\n\n// ============================================================================\n// CACHE MISS - Need to call APIs\n// ============================================================================\n\nreturn {\n  run_metadata: data.run_metadata,\n  asset: data.asset,\n  cache_status: \"miss\",\n  cache_key: data.cache_key || cacheKey || null,\n  cache_lookup_needed: data.cache_lookup_needed\n};\n\n\n// ============================================================================\n// ALTERNATIVE: If you want to be extra safe, check row_number\n// ============================================================================\n/*\nGoogle Sheets lookup returns row_number when a match is found.\nIf row_number exists and is > 1, we definitely have a cache hit.\n\nconst hasSheetRow = data.row_number && data.row_number > 1;\n\nif (hasSheetRow && cacheValid) {\n  // CACHE HIT\n  ...\n}\n*/"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        5872,
        1616
      ],
      "id": "9b686a7a-735b-47a2-b64d-72bf5b93002c",
      "name": "Process Cache Result"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "f45017a4-cdca-4225-9e7e-91e0cdf87c47",
              "leftValue": "={{ $json.cache_status }}",
              "rightValue": "hit",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        6080,
        1616
      ],
      "id": "67146631-3e88-4280-bca9-dc482efd904a",
      "name": "If3"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * CACHE WRITE - FIXED VERSION\n * \n * PROBLEM: The Merge node flattens all API responses into root level,\n * not into nested objects like data.biome, data.climate, etc.\n * \n * ACTUAL STRUCTURE after Merge:\n * {\n *   // Biome data (from UNEP-WCMC API)\n *   \"features\": [{ \"attributes\": { \"eco_name\": \"...\", \"biome_name\": \"...\", \"realm\": \"...\" }}],\n *   \"fields\": [...],\n *   \n *   // GBIF data\n *   \"count\": 73,\n *   \"facets\": [{ \"field\": \"IUCN_RED_LIST_CATEGORY\", \"counts\": [...] }],\n *   \n *   // Climate data (Open-Meteo)\n *   \"daily\": { \"temperature_2m_max\": [...], \"precipitation_sum\": [...], ... },\n *   \"daily_units\": {...},\n *   \"hourly\": {...},  // if present\n *   \n *   // Flood data (merged into daily)\n *   \"daily.river_discharge\": [...],\n *   \n *   // ClimateTRACE\n *   \"results\": [...],  // facilities array\n *   \n *   // Asset & metadata\n *   \"asset\": {...},\n *   \"run_metadata\": {...}\n * }\n */\n\n// ============================================================================\n// NODE: Cache Write (FIXED)\n// Position: After Merge node\n// Mode: Run Once for Each Item\n// ============================================================================\n\nconst CACHE_TTL_HOURS = 24 * 7; // 7 days\n\nconst data = $json;\nconst asset = data.asset || {};\n\n// Skip if no coordinates\nif (!asset.lat || !asset.lon) {\n  return data;\n}\n\n// Generate cache key\nconst roundedLat = Math.round(asset.lat * 100) / 100;\nconst roundedLon = Math.round(asset.lon * 100) / 100;\nconst cacheKey = `${roundedLat}_${roundedLon}`;\n\nconst now = new Date();\nconst expiresAt = new Date(now.getTime() + CACHE_TTL_HOURS * 60 * 60 * 1000);\n\n// ============================================================================\n// EXTRACT AND STRUCTURE BIOME DATA\n// ============================================================================\nconst biomeData = {\n  eco_name: data.features?.[0]?.attributes?.eco_name || data.features?.[0]?.attributes?.ECO_NAME || null,\n  biome_name: data.features?.[0]?.attributes?.biome_name || data.features?.[0]?.attributes?.BIOME_NAME || null,\n  realm: data.features?.[0]?.attributes?.realm || data.features?.[0]?.attributes?.REALM || null,\n  // Keep raw for debugging\n  _raw_features: data.features || null\n};\n\n// ============================================================================\n// EXTRACT AND STRUCTURE GBIF DATA\n// ============================================================================\nconst gbifData = {\n  count: data.count || null,\n  facets: data.facets || null,\n  // Parse IUCN categories\n  iucn_categories: (() => {\n    const iucnFacet = (data.facets || []).find(f => f.field === 'IUCN_RED_LIST_CATEGORY');\n    if (!iucnFacet) return null;\n    const cats = {};\n    (iucnFacet.counts || []).forEach(c => { cats[c.name] = c.count; });\n    return cats;\n  })()\n};\n\n// ============================================================================\n// EXTRACT AND STRUCTURE CLIMATE DATA\n// ============================================================================\nconst climateData = {\n  latitude: data.latitude || null,\n  longitude: data.longitude || null,\n  elevation: data.elevation || null,\n  timezone: data.timezone || null,\n  daily_units: data.daily_units || null,\n  daily: data.daily || null,\n  hourly: data.hourly || null,\n  hourly_units: data.hourly_units || null,\n  // Pre-calculate summaries for faster retrieval\n  summary: (() => {\n    const daily = data.daily || {};\n    const temps = daily.temperature_2m_max || [];\n    const tempsMin = daily.temperature_2m_min || [];\n    const precip = daily.precipitation_sum || [];\n    const wind = daily.wind_gusts_10m_max || [];\n    const soil = data.hourly?.soil_moisture_0_to_1cm || [];\n    \n    return {\n      temp_max_avg: temps.length ? temps.reduce((a, b) => a + b, 0) / temps.length : null,\n      temp_min_avg: tempsMin.length ? tempsMin.reduce((a, b) => a + b, 0) / tempsMin.length : null,\n      precip_total: precip.length ? precip.reduce((a, b) => a + b, 0) : null,\n      wind_gust_max: wind.length ? Math.max(...wind) : null,\n      soil_moisture_avg: soil.length ? soil.reduce((a, b) => a + b, 0) / soil.length : null,\n      soil_moisture_min: soil.length ? Math.min(...soil) : null,\n      soil_moisture_max: soil.length ? Math.max(...soil) : null\n    };\n  })()\n};\n\n// ============================================================================\n// EXTRACT AND STRUCTURE FLOOD DATA\n// ============================================================================\nconst floodData = {\n  daily: {\n    river_discharge: data.daily?.river_discharge || null,\n    river_discharge_max: data.daily?.river_discharge_max || null,\n    river_discharge_p75: data.daily?.river_discharge_p75 || null\n  },\n  summary: (() => {\n    const discharge = data.daily?.river_discharge || [];\n    const dischargeMax = data.daily?.river_discharge_max || [];\n    return {\n      river_discharge_avg: discharge.length ? discharge.reduce((a, b) => a + b, 0) / discharge.length : null,\n      river_discharge_max_peak: dischargeMax.length ? Math.max(...dischargeMax) : null\n    };\n  })()\n};\n\n// ============================================================================\n// EXTRACT AND STRUCTURE CLIMATETRACE DATA\n// ============================================================================\nconst climatetraceData = {\n  results: data.results || null,\n  facilities_count: Array.isArray(data.results) ? data.results.length : 0,\n  // Summarize emissions\n  summary: (() => {\n    const facilities = data.results || [];\n    if (!Array.isArray(facilities) || facilities.length === 0) return null;\n    \n    let totalEmissions = 0;\n    const bySector = {};\n    \n    facilities.forEach(f => {\n      const emissions = f.EmissionsSummary?.[0]?.EmissionsQuantity || 0;\n      totalEmissions += emissions;\n      const sector = f.Sector || 'unknown';\n      bySector[sector] = (bySector[sector] || 0) + emissions;\n    });\n    \n    return {\n      total_emissions: totalEmissions,\n      by_sector: bySector,\n      top_emitter: facilities.sort((a, b) => \n        (b.EmissionsSummary?.[0]?.EmissionsQuantity || 0) - \n        (a.EmissionsSummary?.[0]?.EmissionsQuantity || 0)\n      )[0]?.Name || null\n    };\n  })()\n};\n\n// ============================================================================\n// BUILD CACHE ROW\n// ============================================================================\nconst cacheRow = {\n  cache_key: cacheKey,\n  lat: asset.lat,\n  lon: asset.lon,\n  \n  // Store as JSON strings for Google Sheets\n  biome_data: JSON.stringify(biomeData),\n  gbif_data: JSON.stringify(gbifData),\n  climate_data: JSON.stringify(climateData),\n  flood_data: JSON.stringify(floodData),\n  climatetrace_data: JSON.stringify(climatetraceData),\n  \n  cached_at: now.toISOString(),\n  expires_at: expiresAt.toISOString()\n};\n\n// Return with cache row attached\nreturn {\n  ...data,\n  cache_write_row: cacheRow,\n  \n  // Also add structured data for downstream use (optional but helpful)\n  _cached_biome: biomeData,\n  _cached_gbif: gbifData,\n  _cached_climate: climateData,\n  _cached_flood: floodData,\n  _cached_climatetrace: climatetraceData\n};\n\n\n// ============================================================================\n// VERIFICATION: Check what we're actually caching\n// ============================================================================\n/*\nAfter running, cache_write_row should look like:\n\n{\n  \"cache_key\": \"-15.79_-47.88\",\n  \"lat\": -15.79,\n  \"lon\": -47.88,\n  \"biome_data\": \"{\\\"eco_name\\\":\\\"Cerrado\\\",\\\"biome_name\\\":\\\"Tropical & Subtropical Grasslands...\\\",\\\"realm\\\":\\\"Neotropic\\\"}\",\n  \"gbif_data\": \"{\\\"count\\\":73,\\\"iucn_categories\\\":{\\\"LC\\\":1}}\",\n  \"climate_data\": \"{\\\"summary\\\":{\\\"temp_max_avg\\\":26.65,\\\"precip_total\\\":15.5,...}}\",\n  \"flood_data\": \"{\\\"summary\\\":{\\\"river_discharge_avg\\\":24.35,\\\"river_discharge_max_peak\\\":987.55}}\",\n  \"climatetrace_data\": \"{\\\"facilities_count\\\":0,\\\"summary\\\":null}\",\n  \"cached_at\": \"2026-01-07T15:05:10.842Z\",\n  \"expires_at\": \"2026-01-14T15:05:10.842Z\"\n}\n*/"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7120,
        1072
      ],
      "id": "a40ae354-5335-4a8a-8617-cb1da7b05083",
      "name": "Cache Write"
    },
    {
      "parameters": {
        "operation": "appendOrUpdate",
        "documentId": {
          "__rl": true,
          "value": "",
          "mode": "url"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "Sheet1",
          "cachedResultUrl": ""
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Cache Key": "={{ $json.cache_write_row.cache_key }}",
            "Lat": "={{ $json.cache_write_row.lat }}",
            "Lon": "={{ $json.cache_write_row.lon }}",
            "Biome Data": "={{ $json.cache_write_row.biome_data }}",
            "Gbif Data": "={{ $json.cache_write_row.gbif_data }}",
            "Climate Data": "={{ $json.cache_write_row.climate_data }}",
            "Flood Data": "={{ $json.cache_write_row.flood_data }}",
            "Climatetrace Data": "={{ $json.cache_write_row.climatetrace_data }}",
            "Cached At": "={{ $json.cache_write_row.cached_at }}",
            "Expires At": "={{ $json.cache_write_row.expires_at }}"
          },
          "matchingColumns": [
            "Cache Key"
          ],
          "schema": [
            {
              "id": "Cache Key",
              "displayName": "Cache Key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "Lat",
              "displayName": "Lat",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Lon",
              "displayName": "Lon",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Biome Data",
              "displayName": "Biome Data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Gbif Data",
              "displayName": "Gbif Data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Climate Data",
              "displayName": "Climate Data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Flood Data",
              "displayName": "Flood Data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Climatetrace Data",
              "displayName": "Climatetrace Data",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Cached At",
              "displayName": "Cached At",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Expires At",
              "displayName": "Expires At",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "latitude",
              "displayName": "latitude",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "longitude",
              "displayName": "longitude",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "generationtime_ms",
              "displayName": "generationtime_ms",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "utc_offset_seconds",
              "displayName": "utc_offset_seconds",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "timezone",
              "displayName": "timezone",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "timezone_abbreviation",
              "displayName": "timezone_abbreviation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "elevation",
              "displayName": "elevation",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "daily_units",
              "displayName": "daily_units",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "daily",
              "displayName": "daily",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "objectIdFieldName",
              "displayName": "objectIdFieldName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "globalIdFieldName",
              "displayName": "globalIdFieldName",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "geometryType",
              "displayName": "geometryType",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "spatialReference",
              "displayName": "spatialReference",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "fields",
              "displayName": "fields",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "features",
              "displayName": "features",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "offset",
              "displayName": "offset",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "limit",
              "displayName": "limit",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "endOfRecords",
              "displayName": "endOfRecords",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "results",
              "displayName": "results",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "facets",
              "displayName": "facets",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "run_metadata",
              "displayName": "run_metadata",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "asset",
              "displayName": "asset",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "cache_key",
              "displayName": "cache_key",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "cache_lookup_needed",
              "displayName": "cache_lookup_needed",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "cache_status",
              "displayName": "cache_status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "hourly_units",
              "displayName": "hourly_units",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "hourly",
              "displayName": "hourly",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "bbox",
              "displayName": "bbox",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "assets",
              "displayName": "assets",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "cache_write_row",
              "displayName": "cache_write_row",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        7424,
        1072
      ],
      "id": "aa378607-97eb-4b53-aa05-bb4c211e7559",
      "name": "Append or update row in sheet1",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "",
          "name": "Google Sheets account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        5856,
        1408
      ],
      "id": "e5932c06-4b61-476c-9878-977d6c7c05ac",
      "name": "Merge2"
    },
    {
      "parameters": {
        "content": "Cache Configuration",
        "height": 432,
        "width": 656
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        5376,
        1360
      ],
      "typeVersion": 1,
      "id": "53193b58-3611-4f14-bcf4-06b1f7fce081",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "Cache Configuration",
        "height": 256,
        "width": 624
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        7056,
        992
      ],
      "typeVersion": 1,
      "id": "d39bd2fd-35eb-4ca5-adc7-347b93b1c085",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "content": "TNFD Classifier",
        "height": 256,
        "width": 1088,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        7504,
        1312
      ],
      "typeVersion": 1,
      "id": "50924e63-5c8d-498b-bd9d-af921bdb9b0a",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "AI generation and Evaluation\n",
        "height": 960,
        "width": 3808,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        8656,
        1120
      ],
      "typeVersion": 1,
      "id": "df3605cc-f7b1-46e9-a4b4-b5dbbeddbe06",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "content": "Output",
        "height": 544,
        "width": 304
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        12704,
        1328
      ],
      "typeVersion": 1,
      "id": "09d1c199-ddd2-45bc-9151-c8137ffc4ae5",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "Input",
        "height": 224,
        "width": 256
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        3280,
        1216
      ],
      "typeVersion": 1,
      "id": "24a5f95f-a344-4a37-9a3a-cd5727d57e3c",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * STRIP RAW ARRAYS FOR AGENTS (Simplified Cleanup)\n * \n * PURPOSE:\n * Remove bulky raw arrays from the Normalize JSON2 output to reduce token usage\n * for AI agents. The summaries are already calculated - we just strip the raw data.\n * \n * PLACEMENT:\n * After: Normalize JSON2\n * Before: Initialize loop context\n * \n * INPUT: Normalize JSON2 output (already has summaries calculated)\n * OUTPUT: Same structure but with raw arrays removed\n * \n * WHAT GETS STRIPPED:\n * - climate.raw.daily (hourly arrays)\n * - climate.raw.hourly (soil moisture arrays)  \n * - biodiversity_gbif_iucn.raw (facets, etc.)\n * - biome.raw (geometry data)\n * \n * Node Type: Code\n * Mode: Run Once for Each Item\n * Name: \"Strip Raw Arrays\"\n */\n\nconst data = $json;\n\n// Helper functions\nconst safeNum = (v) => (Number.isFinite(Number(v)) ? Number(v) : null);\nconst round = (v, decimals = 2) => {\n  if (v === null || v === undefined || !Number.isFinite(Number(v))) return null;\n  return Number(Number(v).toFixed(decimals));\n};\n\n// ============================================================================\n// COPY EXISTING DATA (preserving all fields from Normalize JSON2)\n// ============================================================================\n\nconst output = {\n  // Pass through unchanged\n  run_metadata: data.run_metadata,\n  asset: data.asset,\n  quality: data.quality,\n  loopContext: data.loopContext,\n  nature_dependency: data.nature_dependency,\n  \n  // =========================================================================\n  // BIOME - Keep summary, strip raw\n  // =========================================================================\n  biome: {\n    biome_name: data.biome?.biome_name || null,\n    eco_name: data.biome?.eco_name || null,\n    realm: data.biome?.realm || null\n    // Stripped: raw\n  },\n  \n  // =========================================================================\n  // BIODIVERSITY - Keep summary, strip raw\n  // =========================================================================\n  biodiversity_gbif_iucn: {\n    gbif_count: data.biodiversity_gbif_iucn?.gbif_count || null,\n    iucn_red_list_category_counts: data.biodiversity_gbif_iucn?.iucn_red_list_category_counts || null\n    // Stripped: raw\n  },\n  \n  // =========================================================================\n  // CLIMATE - Keep summaries, strip raw arrays\n  // =========================================================================\n  climate: {\n    location: data.climate?.location || null,\n    units: data.climate?.units || null,\n    daily_summary: data.climate?.daily_summary || {\n      temp_max_avg: null,\n      temp_min_avg: null,\n      precip_total: null,\n      wind_gust_max: null\n    },\n    soil_moisture_summary: data.climate?.soil_moisture_summary || {\n      sm_avg: null,\n      sm_min: null,\n      sm_max: null\n    }\n    // Stripped: raw (contains daily arrays, hourly arrays)\n  },\n  \n  // =========================================================================\n  // FLOOD - Extract from climate.raw if exists, otherwise use what's there\n  // =========================================================================\n  flood: {\n    daily_summary: {\n      river_discharge_avg: round(calculateFloodAvg(data)),\n      river_discharge_max_peak: round(calculateFloodMax(data))\n    }\n  },\n  \n  // =========================================================================\n  // CLIMATE TRACE - Pass through (usually already compact)\n  // =========================================================================\n  climate_trace: data.climate_trace || {\n    facilities_count: 0,\n    total_emissions: 0,\n    summary: null\n  }\n};\n\n// ============================================================================\n// HELPER: Calculate flood metrics from raw if available\n// ============================================================================\n\nfunction calculateFloodAvg(data) {\n  // First try existing summary\n  if (data.flood?.daily_summary?.river_discharge_avg) {\n    return data.flood.daily_summary.river_discharge_avg;\n  }\n  // Then try raw arrays\n  const arr = data.climate?.raw?.daily?.river_discharge;\n  if (Array.isArray(arr) && arr.length > 0) {\n    return arr.reduce((a, b) => a + b, 0) / arr.length;\n  }\n  return null;\n}\n\nfunction calculateFloodMax(data) {\n  // First try existing summary\n  if (data.flood?.daily_summary?.river_discharge_max_peak) {\n    return data.flood.daily_summary.river_discharge_max_peak;\n  }\n  // Then try raw arrays\n  const arr = data.climate?.raw?.daily?.river_discharge_max;\n  if (Array.isArray(arr) && arr.length > 0) {\n    return Math.max(...arr);\n  }\n  return null;\n}\n\n// ============================================================================\n// ADD CLEAN ENVIRONMENTAL CONTEXT FOR AI AGENTS\n// ============================================================================\n\nconst biome = output.biome;\nconst biodiv = output.biodiversity_gbif_iucn;\nconst climate = output.climate;\nconst flood = output.flood;\nconst climatetrace = output.climate_trace;\n\n// Calculate threatened species count\nconst iucn = biodiv.iucn_red_list_category_counts || {};\nconst threatenedSpecies = (iucn.CR || 0) + (iucn.EN || 0) + (iucn.VU || 0);\n\n// Calculate soil moisture stress indicator\nconst smAvg = climate.soil_moisture_summary?.sm_avg;\nconst stressIndicator = smAvg !== null && smAvg !== undefined\n  ? (smAvg < 0.15 ? \"high\" : smAvg < 0.25 ? \"medium\" : \"low\")\n  : \"unknown\";\n\n// Calculate flood risk indicator\nconst floodAvg = flood.daily_summary.river_discharge_avg;\nconst floodMax = flood.daily_summary.river_discharge_max_peak;\nconst floodRiskIndicator = (floodMax !== null && floodAvg !== null && floodMax > floodAvg * 3) \n  ? \"elevated\" : \"normal\";\n\noutput.environmental_context = {\n  biome: {\n    biome_name: biome.biome_name,\n    eco_name: biome.eco_name,\n    realm: biome.realm\n  },\n  biodiversity: {\n    species_count: biodiv.gbif_count,\n    search_radius_km: 5,\n    iucn_categories: biodiv.iucn_red_list_category_counts,\n    threatened_species: threatenedSpecies,\n    data_source: \"GBIF\"\n  },\n  climate: {\n    forecast_days: 7,\n    temperature: {\n      max_avg_c: round(climate.daily_summary?.temp_max_avg),\n      min_avg_c: round(climate.daily_summary?.temp_min_avg),\n      range_c: round(\n        climate.daily_summary?.temp_max_avg && climate.daily_summary?.temp_min_avg\n          ? climate.daily_summary.temp_max_avg - climate.daily_summary.temp_min_avg\n          : null\n      )\n    },\n    precipitation: {\n      total_mm: round(climate.daily_summary?.precip_total),\n      daily_avg_mm: round(\n        climate.daily_summary?.precip_total \n          ? climate.daily_summary.precip_total / 7 \n          : null\n      )\n    },\n    wind: {\n      max_gust_kmh: round(climate.daily_summary?.wind_gust_max)\n    },\n    soil_moisture: {\n      avg_m3_m3: round(climate.soil_moisture_summary?.sm_avg, 4),\n      min_m3_m3: round(climate.soil_moisture_summary?.sm_min, 4),\n      max_m3_m3: round(climate.soil_moisture_summary?.sm_max, 4),\n      stress_indicator: stressIndicator\n    },\n    data_source: \"Open-Meteo\"\n  },\n  flood_risk: {\n    river_discharge: {\n      avg_m3_s: round(floodAvg),\n      max_m3_s: round(floodMax),\n      flood_risk_indicator: floodRiskIndicator\n    },\n    data_source: \"Open-Meteo Flood API\"\n  },\n  emissions_context: {\n    facilities_in_radius: climatetrace?.facilities_count || climatetrace?.summary?.facilities_in_radius || 0,\n    search_radius_km: 50,\n    total_emissions_tonnes: round(climatetrace?.total_emissions || climatetrace?.summary?.total_emissions_tonnes || 0),\n    emissions_by_sector: climatetrace?.summary?.emissions_by_sector || null,\n    top_emitter: climatetrace?.summary?.top_emitter || null,\n    data_source: \"Climate TRACE\"\n  }\n};\n\n// ============================================================================\n// ADD RISK INDICATORS\n// ============================================================================\n\nconst facilitiesCount = output.environmental_context.emissions_context.facilities_in_radius;\n\noutput.risk_indicators = {\n  water_stress: stressIndicator,\n  biodiversity_sensitivity: threatenedSpecies > 10 ? \"high\" :\n                            threatenedSpecies > 3 ? \"medium\" : \"low\",\n  flood_exposure: floodRiskIndicator,\n  emissions_proximity: facilitiesCount > 5 ? \"high\" :\n                       facilitiesCount > 1 ? \"medium\" : \"low\"\n};\n\n// ============================================================================\n// ADD DATA QUALITY FLAGS\n// ============================================================================\n\noutput.data_quality = {\n  biome_available: !!biome.biome_name,\n  biodiversity_available: biodiv.gbif_count !== null,\n  climate_available: climate.daily_summary?.temp_max_avg !== null,\n  flood_available: floodAvg !== null,\n  emissions_available: facilitiesCount > 0,\n  data_source: data.cache_status === \"hit\" ? \"cache\" : \"fresh_api\"\n};\n\nreturn output;\n\n// ============================================================================\n// SIZE COMPARISON\n// ============================================================================\n/*\n * STRIPPED (from Normalize JSON2 output):\n * - climate.raw.daily.time[] (30 entries)\n * - climate.raw.daily.river_discharge[] (30 entries)\n * - climate.raw.daily.river_discharge_max[] (30 entries)\n * - climate.raw.daily.river_discharge_p75[] (30 entries)\n * - climate.raw.daily.temperature_2m_max[] (7 entries)\n * - climate.raw.daily.temperature_2m_min[] (7 entries)\n * - climate.raw.daily.precipitation_sum[] (7 entries)\n * - climate.raw.daily.wind_gusts_10m_max[] (7 entries)\n * - climate.raw.hourly.time[] (168 entries)\n * - climate.raw.hourly.soil_moisture_0_to_1cm[] (168 entries)\n * - biodiversity_gbif_iucn.raw.*\n * - biome.raw.*\n * \n * PRESERVED:\n * ✅ run_metadata (unchanged)\n * ✅ asset (unchanged)\n * ✅ biome summary (biome_name, eco_name, realm)\n * ✅ biodiversity summary (gbif_count, iucn_red_list_category_counts)\n * ✅ climate summaries (daily_summary, soil_moisture_summary)\n * ✅ flood summary (calculated from raw if needed)\n * ✅ climate_trace (usually already compact)\n * ✅ nature_dependency (unchanged - needed by downstream)\n * ✅ loopContext (unchanged - needed by loop)\n * ✅ quality (unchanged)\n * \n * ADDED:\n * + environmental_context (clean structure for AI agents)\n * + risk_indicators (pre-calculated)\n * + data_quality (flags)\n * \n * INPUT SIZE:  ~15,000-25,000 characters (with raw arrays)\n * OUTPUT SIZE: ~4,000-5,000 characters\n * REDUCTION:   ~75-80%\n */"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        7680,
        1616
      ],
      "id": "05adc3ca-d2ab-4d46-b167-6dd8f3cc6e1a",
      "name": "Clean API data(optional)"
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "Retrieve necessary chunks of text depending on input",
        "pineconeIndex": {
          "__rl": true,
          "value": "adaptationdocs",
          "mode": "list",
          "cachedResultName": "adaptationdocs"
        },
        "topK": 15,
        "options": {
          "pineconeNamespace": "adaptationdocs"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePinecone",
      "typeVersion": 1.3,
      "position": [
        10192,
        1632
      ],
      "id": "d14efec6-d170-4219-8c9a-adb022d31479",
      "name": "Pinecone Vector Store",
      "credentials": {
        "pineconeApi": {
          "id": "",
          "name": "PineconeApi account 2"
        }
      }
    },
    {
      "parameters": {
        "model": "text-embedding-3-large",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        10288,
        1840
      ],
      "id": "fd610ef1-063b-46e5-882b-7904233573c6",
      "name": "Embeddings OpenAI1",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 5000,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        10048,
        1632
      ],
      "id": "e13d6066-8e2a-410d-8e11-ee4173fd7266",
      "name": "OpenAI Chat Model2",
      "credentials": {
        "openAiApi": {
          "id": "",
          "name": "OpenAi account 2"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.adaptation_strategist_prompt.user }}",
        "options": {
          "systemMessage": "={{ $json.adaptation_strategist_prompt.system }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        10112,
        1328
      ],
      "id": "77c5381c-a834-4524-bbff-f3880a3a9429",
      "name": "Adaptation strategist"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * AGENT 1: Evidence Synthesizer (v2.1 - With Feedback Loop Support)\n * \n * PURPOSE:\n * Retrieves and synthesizes evidence from the knowledge base to ground each\n * identified nature-risk pathway in authoritative sources.\n * \n * KEY CHANGE IN v2.1: Feedback Loop Support\n * - Checks for evaluator feedback from previous iteration\n * - Incorporates improvement guidance into the prompt\n * - Tracks attempt number for context\n * \n * POSITION IN PIPELINE:\n * After: initialise counter (INSIDE the feedback loop)\n * Before: Parse Evidence Output → Adaptation Strategist\n * \n * LOOP FLOW:\n * initialise counter → Build Evidence Prompt → Evidence Synthesizer → ... → Evaluator\n *       ↑                                                                      ↓\n *       └──────────────── Merge Feedback ←──────── If2 (retry) ←──────────────┘\n * \n * INPUTS:\n * - $json.nature_dependency (from Dependency Mapper)\n * - $json.tnfd_scenario_frame (from TNFD Axes + Scenario)\n * - $json.rag_queries (from Query Builder - OUTSIDE loop)\n * - $json.financial_impact (from Financial Engine)\n * - $json.asset (asset context)\n * - $json.agent_attempt (iteration number, from initialise counter)\n * - $json.evaluation_feedback (from Evaluator, if retry)\n * - $json.previous_feedback (alternative field name)\n * \n * N8N CONFIGURATION:\n * - Node Type: Code\n * - Mode: Run Once for Each Item\n * - Position: AFTER initialise counter, INSIDE the feedback loop\n */\n\n// ============================================================================\n// SYSTEM PROMPT\n// ============================================================================\n\nconst EVIDENCE_SYNTHESIZER_SYSTEM_PROMPT = `You are an Evidence Synthesizer specializing in nature-related financial risk analysis. Your role is to ground identified risk pathways in authoritative evidence from TNFD guidance, regulatory frameworks, academic literature, and real-world case studies.\n\n## YOUR TASK\n\nGiven:\n1. An asset's nature dependency profile and financial exposure estimates\n2. The selected TNFD scenario\n3. Suggested retrieval queries for the Pinecone knowledge base\n4. (If revision) Feedback from the evaluator on what to improve\n\nYou must:\n1. Use the Pinecone tool to retrieve relevant evidence for each critical pathway\n2. Synthesize an evidence base that validates and grounds each pathway\n3. Assess evidence strength and identify gaps\n\n## TOOL: Pinecone Vector Store\n\nYou have access to a Pinecone vector store containing:\n- TNFD Recommendations and Guidance (v1.0)\n- NGFS Nature-related Scenarios\n- DNB Biodiversity Stress Test methodology\n- ENCORE Ecosystem Service documentation\n- Nature risk case studies and precedents\n- Regulatory guidance (EU Taxonomy, CSRD, etc.)\n\n### How to Use the Pinecone Tool\n\n1. **Execute suggested queries**: The user prompt includes pre-built queries from the Query Builder. Start with these.\n\n2. **Review and refine**: If initial results are insufficient:\n   - Try more specific queries (add sector, country, specific service)\n   - Try broader queries if too specific\n   - Try alternative phrasings\n\n3. **Query tips for good retrieval**:\n   - Keep queries focused: 50-100 words max\n   - Include the ecosystem service name\n   - For case studies: add \"case study\", \"example\", \"incident\", company names\n   - For thresholds: add \"threshold\", \"tipping point\", \"trigger\", \"limit\"\n   - For methodology: add \"TNFD\", \"LEAP\", \"methodology\", \"guidance\"\n\n4. **Retrieval targets per pathway**:\n   - At least 1 framework/guidance source\n   - At least 1 empirical precedent (if available)\n   - Quantified thresholds (if available)\n\n### When Retrieval is Insufficient\n\nIf you cannot find relevant evidence after 2-3 query attempts:\n- Mark evidence strength as \"Insufficient\"\n- Note what you searched for\n- Do NOT fabricate sources or quotes\n- This is valuable information - it identifies knowledge gaps\n\n## OUTPUT FORMAT\n\nYou MUST respond with valid JSON matching this exact schema:\n\n{\n  \"evidence_synthesis\": {\n    \"asset_id\": \"string\",\n    \"scenario_name\": \"string\",\n    \"synthesis_timestamp\": \"ISO datetime\",\n    \"attempt_number\": 1,\n    \n    \"retrieval_summary\": {\n      \"queries_executed\": 0,\n      \"total_chunks_reviewed\": 0,\n      \"sources_cited\": 0\n    },\n    \n    \"pathways\": [\n      {\n        \"pathway_id\": \"P1\",\n        \"pathway_name\": \"string (e.g., 'Surface Water Scarcity → Production Disruption')\",\n        \"ecosystem_service\": \"string\",\n        \"dependency_strength\": \"Very High | High | Medium | Low\",\n        \n        \"retrieval_log\": {\n          \"queries_used\": [\"string (queries you executed)\"],\n          \"chunks_reviewed\": 0,\n          \"relevant_chunks_found\": 0\n        },\n        \n        \"framework_support\": {\n          \"has_support\": true,\n          \"sources\": [\n            {\n              \"framework\": \"TNFD | NGFS | DNB | ENCORE | SBTN | EU Taxonomy\",\n              \"document\": \"string (document name)\",\n              \"reference\": \"string (e.g., 'Section 4.2.3' or 'Page 47')\",\n              \"relevant_quote\": \"string (max 100 words, actual quote from chunk)\",\n              \"alignment_note\": \"string (how this applies to the specific asset)\"\n            }\n          ]\n        },\n        \n        \"empirical_precedents\": {\n          \"has_precedents\": true,\n          \"cases\": [\n            {\n              \"entity\": \"string (company/region)\",\n              \"year\": \"string\",\n              \"event\": \"string (what happened)\",\n              \"impact\": \"string (quantified if possible)\",\n              \"source\": \"string (where you found this)\",\n              \"relevance\": \"High | Medium | Low\",\n              \"relevance_note\": \"string (why this is relevant to the asset)\"\n            }\n          ]\n        },\n        \n        \"quantified_thresholds\": {\n          \"has_thresholds\": true,\n          \"thresholds\": [\n            {\n              \"metric\": \"string (e.g., 'baseline water stress')\",\n              \"threshold_value\": \"string (e.g., '>40%')\",\n              \"consequence\": \"string (what happens when exceeded)\",\n              \"source\": \"string\",\n              \"applicability\": \"string (how relevant to this asset)\"\n            }\n          ]\n        },\n        \n        \"transmission_mechanism\": {\n          \"description\": \"string (how the physical risk transmits to financial impact)\",\n          \"channels\": [\"operational costs\", \"revenue disruption\", \"capex requirements\", \"asset impairment\", \"liability\"],\n          \"source\": \"string (if from retrieved evidence)\"\n        },\n        \n        \"evidence_assessment\": {\n          \"strength\": \"High | Medium | Low | Insufficient\",\n          \"confidence_factors\": [\"string (what supports confidence)\"],\n          \"gaps\": [\"string (what evidence is missing)\"],\n          \"recommendations\": [\"string (what additional evidence would strengthen this)\"]\n        }\n      }\n    ],\n    \n    \"cross_cutting_themes\": [\n      {\n        \"theme\": \"string (e.g., 'Regulatory tightening across all pathways')\",\n        \"description\": \"string\",\n        \"relevant_pathways\": [\"P1\", \"P3\"],\n        \"source\": \"string (if from evidence)\"\n      }\n    ],\n    \n    \"knowledge_gaps\": [\n      {\n        \"gap\": \"string\",\n        \"queries_attempted\": [\"string\"],\n        \"impact_on_analysis\": \"string\",\n        \"suggested_sources\": [\"string\"]\n      }\n    ],\n    \n    \"sources_bibliography\": [\n      {\n        \"id\": \"S1\",\n        \"document\": \"string\",\n        \"framework\": \"string\",\n        \"used_for_pathways\": [\"P1\", \"P2\"]\n      }\n    ],\n    \n    \"revision_notes\": \"string (if this is a revision, note what was improved)\",\n    \n    \"methodology_note\": \"string (brief note on synthesis approach and retrieval strategy)\"\n  }\n}\n\n## EVIDENCE STRENGTH CRITERIA\n\nRate evidence strength as:\n- **High**: Multiple independent sources, quantified thresholds, direct empirical precedents from retrieved chunks\n- **Medium**: Framework support with limited empirical validation, or single strong source\n- **Low**: Theoretical pathway with minimal direct evidence from retrieval\n- **Insufficient**: Pathway identified but no supporting evidence found despite queries\n\n## CRITICAL RULES\n\n1. **Only cite what you retrieve**: Every source must come from Pinecone chunks you actually retrieved\n2. **No fabrication**: If you can't find evidence, say so - this is valuable information\n3. **Quote accurately**: When quoting, use actual text from retrieved chunks\n4. **Log your retrieval**: Track which queries you ran and what you found\n5. **Be specific about applicability**: Generic guidance is less valuable than sector/context-specific\n6. **Acknowledge limitations**: Note when evidence is tangential or from different contexts\n\n## IF THIS IS A REVISION\n\nIf you see a \"REVISION REQUIRED\" section in the prompt:\n1. **Read the feedback carefully** - understand exactly what was wrong\n2. **Address each critical issue** - don't repeat the same mistakes\n3. **Note what you changed** in the revision_notes field\n4. **Re-query if needed** - if the issue was poor evidence, try different queries\n5. **Be more rigorous** - the evaluator found problems, so be extra careful\n\n## TONE\n\nProfessional, analytical, precise. You are building a defensible evidence base that could be reviewed by a sustainability auditor or nature risk specialist. Intellectual honesty about gaps is more valuable than false confidence.`;\n\n// ============================================================================\n// FEEDBACK SECTION BUILDER\n// ============================================================================\n\nfunction buildFeedbackSection(data) {\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  const feedback = data.evaluation_feedback || data.previous_feedback || data.evaluation_result || null;\n  \n  // No feedback section needed for first attempt\n  if (attemptNumber <= 1 || !feedback) {\n    return '';\n  }\n  \n  // Extract evidence synthesizer specific feedback\n  const agentEval = feedback.agent_evaluations?.evidence_synthesizer || \n                    feedback.evidence_synthesizer ||\n                    {};\n  \n  const score = agentEval.score || 'N/A';\n  const criticalIssues = agentEval.critical_issues || [];\n  const improvementFeedback = agentEval.improvement_feedback || 'No specific feedback provided.';\n  const criteriaScores = agentEval.criteria_scores || {};\n  \n  // Build list of criteria that need improvement (score < 75)\n  const weakCriteria = Object.entries(criteriaScores)\n    .filter(([_, v]) => v && v.score < 75)\n    .map(([k, v]) => `- **${k}** (${v.score}/100): ${v.notes || 'Needs improvement'}`)\n    .join('\\n');\n  \n  // Check for hallucination issues\n  const hallucinations = feedback.hallucination_check?.instances || [];\n  const evidenceHallucinations = hallucinations.filter(h => h.agent === 'evidence_synthesizer');\n  \n  let hallucinationWarning = '';\n  if (evidenceHallucinations.length > 0) {\n    hallucinationWarning = `\n### ⚠️ HALLUCINATION DETECTED IN PREVIOUS OUTPUT\n\nThe following claims were flagged as potentially fabricated:\n${evidenceHallucinations.map(h => `- \"${h.claim}\" - Issue: ${h.issue}`).join('\\n')}\n\n**DO NOT repeat these errors.** Only cite sources you actually retrieve from Pinecone.\n`;\n  }\n  \n  // Check cross-agent consistency issues\n  const consistencyIssues = feedback.cross_agent_consistency?.issues || [];\n  let consistencyWarning = '';\n  if (consistencyIssues.length > 0) {\n    consistencyWarning = `\n### Cross-Agent Consistency Issues\n${consistencyIssues.map(i => `- ${i}`).join('\\n')}\n`;\n  }\n  \n  return `\n## ⚠️ REVISION REQUIRED (Attempt ${attemptNumber} of 3)\n\nYour previous output was evaluated and needs improvement.\n\n### Evaluation Score: ${score}/100 ${score >= 75 ? '(Passed but needs refinement)' : '(Below threshold - must improve)'}\n\n### Critical Issues to Address:\n${criticalIssues.length > 0 ? criticalIssues.map(i => `- ❌ ${i}`).join('\\n') : '- No critical issues flagged'}\n\n### Specific Improvement Guidance:\n${improvementFeedback}\n\n### Criteria Needing Improvement:\n${weakCriteria || '- All criteria met minimum threshold'}\n${hallucinationWarning}${consistencyWarning}\n\n### What You Must Do Differently:\n1. **Re-read the feedback above** and understand each issue\n2. **Re-query Pinecone** if the issue was insufficient evidence\n3. **Be more precise** in citations - only quote what you actually retrieved\n4. **Fill identified gaps** - search for missing evidence types\n5. **Note your changes** in the revision_notes field\n\n---\n\n`;\n}\n\n// ============================================================================\n// USER PROMPT BUILDER\n// ============================================================================\n\nfunction buildEvidenceSynthesizerPrompt(data) {\n  const asset = data.asset || {};\n  const nd = data.nature_dependency || {};\n  const frame = data.tnfd_scenario_frame || {};\n  const ragQueries = data.rag_queries || [];\n  const ragStrategy = data.rag_strategy || {};\n  const financial = data.financial_impact || {};\n  const shockSummary = data.shock_summary || {};\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  \n  // Build feedback section (empty string if first attempt)\n  const feedbackSection = buildFeedbackSection(data);\n  \n  // Get critical dependencies (Very High and High only)\n  const criticalDeps = (nd.dependencies || []).filter(d => \n    d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\"\n  );\n  \n  // Format suggested queries for the agent\n  const formattedQueries = ragQueries.map((q, i) => {\n    let queryBlock = `\n### Query ${i + 1}: ${q.type.toUpperCase()}\n**Intent:** ${q.intent}\n**Suggested Query:** \n\\`\\`\\`\n${q.query}\n\\`\\`\\`\n**Recommended Top-K:** ${q.top_k}`;\n    \n    if (q.ecosystem_service) {\n      queryBlock += `\\n**Target Service:** ${q.ecosystem_service}`;\n    }\n    if (q.keywords && q.keywords.length > 0) {\n      queryBlock += `\\n**Keywords to look for:** ${q.keywords.join(', ')}`;\n    }\n    if (q.transmission_channels && q.transmission_channels.length > 0) {\n      queryBlock += `\\n**Transmission channels:** ${q.transmission_channels.join(', ')}`;\n    }\n    \n    return queryBlock;\n  }).join('\\n\\n');\n\n  // Format financial context\n  let financialContext = 'No financial estimates available yet.';\n  if (financial.headline) {\n    financialContext = `\n**Headline:** ${financial.headline.headline_text || 'Calculated'}\n**Severe Exposure (Mid):** €${(financial.severe_total_eur || 0).toLocaleString()}\n**Top Drivers:**\n${(financial.top_drivers || []).map(d => `- ${d.ecosystem_service}: €${(d.severe_total_eur || 0).toLocaleString()}`).join('\\n')}`;\n  }\n\n  // Format critical dependencies with more detail\n  const depsFormatted = criticalDeps.map((d, i) => `\n### Dependency ${i + 1}: ${d.ecosystem_service}\n- **Strength:** ${d.dependency_strength}\n- **Category:** ${d.category}\n- **Type:** ${d.dependency_type}\n- **Substitutability:** ${d.substitutability}\n- **Time to Failure:** ${d.time_to_failure}\n- **Rationale:** ${d.rationale}\n- **Confidence:** ${d.confidence || 'Not specified'}\n`).join('\\n');\n\n  return `${feedbackSection}## ASSET CONTEXT\n\n**Asset ID:** ${asset.asset_id || 'Unknown'}\n**Sector:** ${nd.sector || asset.sector || 'Unknown'}\n**Asset Type:** ${nd.asset_type || asset.asset_type || 'Unknown'}\n**Country:** ${asset.country || 'Unknown'}\n**Value:** €${(asset.value_eur || 0).toLocaleString()}\n**Analysis Attempt:** ${attemptNumber} of 3\n\n## ENVIRONMENTAL CONTEXT\n\n**Biome:** ${nd.environmental_context?.biome || 'Unknown'}\n**Ecoregion:** ${nd.environmental_context?.ecoregion || 'Unknown'}\n**Water Stress Level:** ${nd.environmental_context?.water_stress_level || 'Unknown'}\n**Biodiversity Sensitivity:** ${nd.environmental_context?.biodiversity_sensitivity || 'Unknown'}\n**Biome Sensitivity Factor:** ${nd.environmental_context?.biome_sensitivity_factor || 'Unknown'}\n\n## TNFD SCENARIO\n\n**Scenario:** ${frame.scenario?.scenario_name || 'Unknown'}\n**Description:** ${frame.scenario_detail?.description || 'Not available'}\n**Risk Posture:** ${frame.scenario_detail?.risk_posture || 'Not specified'}\n\n**Physical Risk Score:** ${frame.axes?.ecosystem_service_degradation?.toFixed(2) || 'N/A'} (${frame.physical_axis_detail?.interpretation || ''})\n**Transition Risk Score:** ${frame.axes?.market_nonmarket_alignment?.toFixed(2) || 'N/A'} (${frame.transition_axis_detail?.interpretation || ''})\n**Horizon Year:** ${frame.horizon_year || 2030}\n\n## PRELIMINARY FINANCIAL EXPOSURE\n\n${financialContext}\n\n*Note: These estimates will be refined based on your evidence synthesis.*\n\n## CRITICAL DEPENDENCIES TO GROUND WITH EVIDENCE\n\n${criticalDeps.length > 0 ? depsFormatted : 'No critical dependencies identified. Review the full dependency list.'}\n\n**Total Dependencies:** ${(nd.dependencies || []).length}\n**Critical (Very High + High):** ${criticalDeps.length}\n\n## SUGGESTED RAG QUERIES\n\nThe Query Builder has prepared the following queries based on the asset context. \n**Use the Pinecone tool to execute these queries** and retrieve relevant evidence.\n\n${formattedQueries || 'No queries prepared. Construct your own based on the critical dependencies above.'}\n\n### Retrieval Strategy\n${ragStrategy.rationale || 'Execute queries in priority order. Refine if results are insufficient.'}\n\n**Query Budget:** ${ragStrategy.query_count || ragQueries.length} queries suggested\n**Target Chunks:** ~${ragStrategy.total_chunks_target || 15} total\n\n## YOUR TASK\n\n1. **Execute the suggested queries** using the Pinecone tool\n2. **Review retrieved chunks** for relevance to each critical dependency\n3. **Synthesize evidence** for each pathway:\n   - Framework/guidance support (TNFD, NGFS, DNB, ENCORE)\n   - Empirical precedents (real-world cases)\n   - Quantified thresholds (if available)\n   - Transmission mechanisms (how physical risk → financial impact)\n4. **Assess evidence strength** for each pathway\n5. **Identify gaps** where evidence is insufficient\n6. **Log your retrieval** - which queries you ran, what you found\n${attemptNumber > 1 ? '7. **Address all feedback** from the evaluator and note changes in revision_notes' : ''}\n\n### Key Questions to Answer for Each Pathway\n\n1. Does TNFD/NGFS guidance explicitly address this pathway?\n2. Are there documented cases where this risk materialized?\n3. Are there quantified thresholds or tipping points?\n4. How does this physical risk transmit to financial impact?\n5. What's missing from the evidence base?\n\n### Quality Standards\n\n- Every claim must trace to a retrieved chunk\n- Acknowledge when evidence is indirect or from different contexts\n- \"Insufficient evidence\" is a valid and valuable finding\n- Log query refinements if initial retrieval fails\n${attemptNumber > 1 ? '- **This is attempt ' + attemptNumber + ' - the evaluator found issues with the previous output. Address them.**' : ''}\n\nRespond with valid JSON only. Start with \\`{\\` and end with \\`}\\`.`;\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\n// Build the prompt\nconst userPrompt = buildEvidenceSynthesizerPrompt($json);\n\n// Track attempt number in output\nconst attemptNumber = $json.agent_attempt || $json.loopContext?.attempt_number || 1;\n\n// Return for use in AI Agent node\nreturn {\n  ...$json,\n  evidence_synthesizer_prompt: {\n    system: EVIDENCE_SYNTHESIZER_SYSTEM_PROMPT,\n    user: userPrompt\n  },\n  current_agent: \"evidence_synthesizer\",\n  current_attempt: attemptNumber\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        8960,
        1328
      ],
      "id": "88827eb5-418a-41ee-a9e1-ba53566b3432",
      "name": "Build Evidence Synthesizer Prompt"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * AGENT 2: Adaptation Strategist (v2.1 - With Feedback Loop Support + RAG)\n * \n * PURPOSE:\n * Generates concrete, actionable adaptation and mitigation strategies based on\n * the identified risks and evidence base. Uses Pinecone RAG for grounding.\n * \n * KEY CHANGES IN v2.1:\n * - Feedback Loop Support: Incorporates evaluator feedback on retry\n * - RAG Integration: Uses Pinecone to ground strategies in SBTN/TNFD guidance\n * \n * POSITION IN PIPELINE:\n * After: Parse Evidence Output (INSIDE the feedback loop)\n * Before: Parse Strategy Output → Narrative Intelligence\n * \n * INPUTS:\n * - $json.nature_dependency (dependencies, matched sectors)\n * - $json.tnfd_scenario_frame (scenario, axes)\n * - $json.evidence_synthesis (from Evidence Synthesizer)\n * - $json.financial_impact (if available)\n * - $json.asset (asset context)\n * - $json.agent_attempt (iteration number)\n * - $json.evaluation_feedback (from Evaluator, if retry)\n * \n * N8N CONFIGURATION:\n * - Node Type: Code\n * - Mode: Run Once for Each Item\n * - Position: INSIDE the feedback loop, after Parse Evidence Output\n */\n\n// ============================================================================\n// SYSTEM PROMPT (RAG-Enhanced + Feedback-Aware)\n// ============================================================================\n\nconst ADAPTATION_STRATEGIST_SYSTEM_PROMPT = `You are an Adaptation Strategist specializing in nature-related risk management. Your role is to translate identified risks and evidence into concrete, actionable strategies that organizations can implement.\n\n## KEY CAPABILITY: RAG-GROUNDED STRATEGIES\n\nYou have access to a Pinecone vector store containing:\n- **SBTN Guidance**: Science Based Targets for Nature methodology, sector guidance\n- **TNFD Response Strategies**: Official TNFD recommendations for strategic response\n- **Implementation Guides**: WWF, WRI, WBCSD practical implementation guidance\n- **Case Studies**: Real-world implementation examples from Nestlé, Unilever, Holcim, AB InBev, etc.\n- **Cost Benchmarks**: Nature-based solutions cost databases, industry studies\n\n### How to Use the Pinecone Tool\n\nFor EVERY strategy you propose, you SHOULD:\n1. **Search for framework guidance** - Query for SBTN/TNFD recommendations on that action type\n2. **Search for implementation examples** - Query for real case studies showing implementation\n3. **Search for cost benchmarks** - Query for cost estimates from similar implementations\n\n### Query Templates for Strategy Retrieval\n\n**For water-related strategies:**\n\\`SBTN freshwater target setting water stewardship corporate implementation\\`\n\\`water recycling industrial implementation cost benchmark case study\\`\n\n**For soil/land strategies:**\n\\`SBTN land target regenerative agriculture implementation\\`\n\\`soil health improvement corporate farming cost benefit\\`\n\n**For biodiversity strategies:**\n\\`TNFD biodiversity net gain implementation corporate\\`\n\\`habitat restoration cost per hectare benchmark\\`\n\n**For general nature strategies:**\n\\`TNFD strategy response nature positive commitment\\`\n\\`nature-based solutions corporate implementation\\`\n\n### Retrieval Standards\n\n- **Minimum 2 queries per critical pathway strategy**\n- **Cite actual sources** from retrieved chunks (not fabricated)\n- **Quote cost ranges** only if found in retrieval\n- **Reference real case studies** only if found in retrieval\n- **Mark as \"No benchmark found\"** if retrieval yields nothing relevant\n\n## OUTPUT FORMAT\n\nYou MUST respond with valid JSON matching this exact schema:\n\n{\n  \"adaptation_strategy\": {\n    \"asset_id\": \"string\",\n    \"scenario_name\": \"string\",\n    \"horizon_year\": 2030,\n    \"strategy_timestamp\": \"ISO datetime\",\n    \"attempt_number\": 1,\n    \n    \"retrieval_summary\": {\n      \"queries_executed\": 0,\n      \"chunks_reviewed\": 0,\n      \"frameworks_cited\": [\"SBTN\", \"TNFD\", \"WWF\"],\n      \"case_studies_found\": 0,\n      \"cost_benchmarks_found\": 0\n    },\n    \n    \"strategic_overview\": {\n      \"risk_posture\": \"string (1-2 sentence summary)\",\n      \"strategic_intent\": \"string (what the strategy aims to achieve)\",\n      \"framework_alignment\": {\n        \"sbtn_alignment\": \"string (which SBTN targets this aligns with)\",\n        \"tnfd_alignment\": \"string (TNFD strategy recommendations)\",\n        \"source\": \"string (retrieved chunk reference)\"\n      },\n      \"total_estimated_investment\": {\n        \"low\": \"number (EUR)\",\n        \"high\": \"number (EUR)\",\n        \"confidence\": \"High | Medium | Low\",\n        \"benchmark_source\": \"string (source or 'Internal estimate')\"\n      },\n      \"potential_risk_reduction\": {\n        \"percentage\": \"number\",\n        \"confidence\": \"High | Medium | Low\",\n        \"basis\": \"string\"\n      }\n    },\n    \n    \"pathway_strategies\": [\n      {\n        \"pathway_id\": \"P1\",\n        \"pathway_name\": \"string\",\n        \"ecosystem_service\": \"string\",\n        \"current_exposure\": \"string\",\n        \n        \"strategy_grounding\": {\n          \"queries_used\": [\"string\"],\n          \"framework_guidance_found\": true,\n          \"case_studies_found\": true,\n          \"cost_benchmarks_found\": true\n        },\n        \n        \"short_term_actions\": {\n          \"timeframe\": \"0-12 months\",\n          \"actions\": [\n            {\n              \"action_id\": \"ST1\",\n              \"title\": \"string\",\n              \"description\": \"string (2-3 sentences)\",\n              \"implementation_steps\": [\"string\"],\n              \"grounding\": {\n                \"framework_alignment\": \"SBTN | TNFD | WWF | None\",\n                \"framework_reference\": \"string (e.g., 'SBTN Freshwater v1.0, Section 3.2')\",\n                \"framework_quote\": \"string (actual quote, max 50 words)\",\n                \"case_study_support\": {\n                  \"entity\": \"string or null\",\n                  \"action_taken\": \"string\",\n                  \"outcome\": \"string\",\n                  \"source\": \"string\"\n                },\n                \"cost_benchmark\": {\n                  \"range\": \"string (e.g., '€50,000-150,000' or 'Unknown')\",\n                  \"unit\": \"string\",\n                  \"source\": \"string\",\n                  \"confidence\": \"High | Medium | Low | Unknown\"\n                }\n              },\n              \"estimated_cost\": {\n                \"amount_eur\": \"number or null\",\n                \"type\": \"OPEX | CAPEX | Mixed\",\n                \"derivation\": \"string\"\n              },\n              \"risk_reduction\": {\n                \"estimate\": \"string\",\n                \"mechanism\": \"string\",\n                \"evidence_basis\": \"string\"\n              },\n              \"feasibility\": \"High | Medium | Low\",\n              \"co_benefits\": [\"string\"],\n              \"dependencies\": [\"string\"],\n              \"kpis\": [\"string\"]\n            }\n          ]\n        },\n        \n        \"medium_term_investments\": {\n          \"timeframe\": \"1-3 years\",\n          \"actions\": []\n        },\n        \n        \"long_term_transformations\": {\n          \"timeframe\": \"3-10 years\",\n          \"actions\": []\n        }\n      }\n    ],\n    \n    \"cross_cutting_initiatives\": [],\n    \n    \"governance_recommendations\": {\n      \"board_level\": [],\n      \"management_level\": [],\n      \"disclosure_actions\": []\n    },\n    \n    \"implementation_roadmap\": {\n      \"phase_1\": { \"name\": \"Foundation\", \"duration\": \"string\", \"key_milestones\": [] },\n      \"phase_2\": { \"name\": \"Acceleration\", \"duration\": \"string\", \"key_milestones\": [] },\n      \"phase_3\": { \"name\": \"Transformation\", \"duration\": \"string\", \"key_milestones\": [] }\n    },\n    \n    \"monitoring_framework\": {\n      \"leading_indicators\": [],\n      \"lagging_indicators\": [],\n      \"early_warning_triggers\": []\n    },\n    \n    \"grounding_summary\": {\n      \"total_strategies_proposed\": 0,\n      \"strategies_with_framework_support\": 0,\n      \"strategies_with_case_study_support\": 0,\n      \"strategies_with_cost_benchmarks\": 0,\n      \"gaps_identified\": [],\n      \"confidence_assessment\": \"string\"\n    },\n    \n    \"constraints_and_limitations\": {\n      \"assumptions\": [],\n      \"uncertainties\": [],\n      \"external_dependencies\": [],\n      \"resource_constraints\": [],\n      \"knowledge_gaps\": []\n    },\n    \n    \"revision_notes\": \"string (if revision, note what was improved)\",\n    \n    \"sources_bibliography\": [],\n    \n    \"methodology_note\": \"string\"\n  }\n}\n\n## STRATEGY PRINCIPLES\n\n1. **Evidence-backed over intuitive**: Strategies grounded in SBTN/TNFD guidance are more defensible\n2. **Specificity over generality**: \"Install closed-loop cooling targeting 40% reduction per SBTN Freshwater\" beats \"Implement water recycling\"\n3. **Real costs over estimates**: Use retrieved benchmarks; acknowledge uncertainty if estimated\n4. **Cite everything**: Every reference should trace to a retrieved chunk\n5. **Gaps are valuable**: Identifying where guidance doesn't exist is important\n\n## IF THIS IS A REVISION\n\nIf you see a \"REVISION REQUIRED\" section in the prompt:\n1. **Read the feedback carefully** - understand what was wrong\n2. **Address each critical issue** - don't repeat mistakes\n3. **Be more specific** if strategies were \"vague\"\n4. **Add cost sources** if costs were \"unsubstantiated\"  \n5. **Re-query Pinecone** if evidence was insufficient\n6. **Note changes** in revision_notes field\n\n## TONE\n\nPragmatic, business-oriented, actionable, evidence-based. You are advising a COO or Head of Sustainability who needs a defensible business case.`;\n\n// ============================================================================\n// STRATEGY RAG QUERIES BUILDER\n// ============================================================================\n\nfunction buildStrategyQueries(dependencies, sector, scenario, country) {\n  const queries = [];\n  \n  const criticalDeps = (dependencies || []).filter(d => \n    d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\"\n  );\n  \n  // General TNFD Strategy Query\n  queries.push({\n    type: \"framework_strategy\",\n    query: `TNFD strategy response ${scenario} nature positive corporate implementation`,\n    intent: \"Retrieve TNFD strategic response guidance\",\n    ecosystem_service: \"General\"\n  });\n  \n  // SBTN Target Setting Query\n  queries.push({\n    type: \"sbtn_targets\",\n    query: `SBTN science based targets nature ${sector} target setting methodology`,\n    intent: \"Retrieve SBTN target setting methodology\",\n    ecosystem_service: \"General\"\n  });\n  \n  // Service-specific queries\n  const serviceQueries = {\n    \"Surface Water\": [\"water stewardship SBTN freshwater target AWS\", \"water recycling cost benchmark\"],\n    \"Ground Water\": [\"groundwater management aquifer corporate\", \"water efficiency implementation\"],\n    \"Pollination\": [\"pollinator habitat restoration cost\", \"integrated pest management transition\"],\n    \"Soil Quality Regulation\": [\"regenerative agriculture SBTN land\", \"soil health improvement cost\"],\n    \"Flood & Storm Protection\": [\"nature-based solutions flood protection\", \"wetland restoration cost\"],\n    \"Water Quality Regulation\": [\"water treatment natural infrastructure\", \"constructed wetland cost\"],\n    \"Climate Regulation\": [\"nature-based solutions carbon sequestration\", \"ecosystem restoration climate\"],\n    \"Pest & Disease Control\": [\"integrated pest management biological control\", \"natural pest control cost\"]\n  };\n  \n  for (const dep of criticalDeps.slice(0, 4)) {\n    const templates = serviceQueries[dep.ecosystem_service];\n    if (templates) {\n      templates.forEach(t => {\n        queries.push({\n          type: \"service_strategy\",\n          query: `${t} ${sector} ${country}`,\n          intent: `Strategy guidance for ${dep.ecosystem_service}`,\n          ecosystem_service: dep.ecosystem_service\n        });\n      });\n    }\n  }\n  \n  // Cost benchmark query\n  queries.push({\n    type: \"cost_benchmark\",\n    query: `nature-based solutions implementation cost benchmark ROI business case`,\n    intent: \"Retrieve cost benchmarks\",\n    ecosystem_service: \"General\"\n  });\n  \n  return queries;\n}\n\n// ============================================================================\n// FEEDBACK SECTION BUILDER\n// ============================================================================\n\nfunction buildFeedbackSection(data) {\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  const feedback = data.evaluation_feedback || data.previous_feedback || data.evaluation_result || null;\n  \n  if (attemptNumber <= 1 || !feedback) {\n    return '';\n  }\n  \n  const agentEval = feedback.agent_evaluations?.adaptation_strategist || \n                    feedback.adaptation_strategist || {};\n  \n  const score = agentEval.score || 'N/A';\n  const criticalIssues = agentEval.critical_issues || [];\n  const improvementFeedback = agentEval.improvement_feedback || 'No specific feedback provided.';\n  const criteriaScores = agentEval.criteria_scores || {};\n  \n  const weakCriteria = Object.entries(criteriaScores)\n    .filter(([_, v]) => v && v.score < 75)\n    .map(([k, v]) => `- **${k}** (${v.score}/100): ${v.notes || 'Needs improvement'}`)\n    .join('\\n');\n  \n  // Check for hallucinations\n  const hallucinations = feedback.hallucination_check?.instances || [];\n  const strategyHallucinations = hallucinations.filter(h => h.agent === 'adaptation_strategist');\n  \n  let hallucinationWarning = '';\n  if (strategyHallucinations.length > 0) {\n    hallucinationWarning = `\n### ⚠️ HALLUCINATION DETECTED\n\nThe following were flagged as potentially fabricated:\n${strategyHallucinations.map(h => `- \"${h.claim}\" - Issue: ${h.issue}`).join('\\n')}\n\n**Only cite sources you actually retrieve from Pinecone.**\n`;\n  }\n  \n  // Check for consistency issues\n  const consistencyIssues = feedback.cross_agent_consistency?.issues || [];\n  let consistencyWarning = '';\n  if (consistencyIssues.length > 0) {\n    consistencyWarning = `\n### Cross-Agent Consistency Issues\n${consistencyIssues.map(i => `- ${i}`).join('\\n')}\n\nEnsure your strategies align with the evidence from Evidence Synthesizer.\n`;\n  }\n  \n  return `\n## ⚠️ REVISION REQUIRED (Attempt ${attemptNumber} of 3)\n\nYour previous output was evaluated and needs improvement.\n\n### Evaluation Score: ${score}/100 ${score >= 75 ? '(Passed but needs refinement)' : '(Below threshold)'}\n\n### Critical Issues to Address:\n${criticalIssues.length > 0 ? criticalIssues.map(i => `- ❌ ${i}`).join('\\n') : '- No critical issues flagged'}\n\n### Specific Improvement Guidance:\n${improvementFeedback}\n\n### Criteria Needing Improvement:\n${weakCriteria || '- All criteria met minimum threshold'}\n${hallucinationWarning}${consistencyWarning}\n\n### Common Issues to Avoid:\n- **Vague strategies**: \"Improve water management\" → \"Install 500m³/day recycling system\"\n- **Unsubstantiated costs**: Must cite benchmark source or mark as \"Internal estimate\"\n- **Missing case studies**: Search Pinecone for real examples\n- **Ignoring evidence**: Build on Evidence Synthesizer output\n\n---\n\n`;\n}\n\n// ============================================================================\n// USER PROMPT BUILDER\n// ============================================================================\n\nfunction buildAdaptationStrategistPrompt(data) {\n  const asset = data.asset || {};\n  const nd = data.nature_dependency || {};\n  const frame = data.tnfd_scenario_frame || {};\n  const evidence = data.evidence_synthesis || {};\n  const financial = data.financial_impact || data.shock_grid || {};\n  const attemptNumber = data.agent_attempt || data.loopContext?.attempt_number || 1;\n  \n  // Build feedback section\n  const feedbackSection = buildFeedbackSection(data);\n  \n  // Get critical dependencies\n  const criticalDeps = (nd.dependencies || []).filter(d => \n    d.dependency_strength === \"Very High\" || d.dependency_strength === \"High\"\n  );\n  \n  // Build strategy-specific RAG queries\n  const strategyQueries = buildStrategyQueries(\n    nd.dependencies,\n    nd.matched_sectors?.[0] || asset.sector || \"manufacturing\",\n    frame.scenario?.scenario_name || \"Unknown\",\n    asset.country || \"Unknown\"\n  );\n  \n  // Format queries\n  const formattedQueries = strategyQueries.map((q, i) => `\n### Query ${i + 1}: ${q.type.toUpperCase()}\n**Intent:** ${q.intent}\n**Target Service:** ${q.ecosystem_service}\n**Query:** \\`${q.query}\\``).join('\\n');\n  \n  // Format evidence pathways\n  const evidencePathways = (evidence.pathways || []).map((p, i) => `\n### ${p.pathway_name} (${p.ecosystem_service})\n- Dependency Strength: ${p.dependency_strength}\n- Evidence Strength: ${p.evidence_assessment?.strength || 'Unknown'}\n- Key Evidence: ${p.framework_support?.sources?.[0]?.relevant_quote || 'None found'}\n- Precedent: ${p.empirical_precedents?.cases?.[0]?.event || 'None found'}\n- Transmission: ${p.transmission_mechanism?.description || 'Not specified'}\n- Gaps: ${(p.evidence_assessment?.gaps || []).join(', ') || 'None'}`).join('\\n');\n\n  // Format financial context\n  let financialContext = 'No financial impact data available.';\n  if (financial.severe_total_eur || financial.total_exposure) {\n    financialContext = `\n- Severe scenario: €${(financial.severe_total_eur || financial.total_exposure || 0).toLocaleString()}\n- OPEX impact: €${(financial.opex_eur || 0).toLocaleString()}\n- CAPEX impact: €${(financial.capex_eur || 0).toLocaleString()}\n- Revenue at risk: €${(financial.revenue_eur || 0).toLocaleString()}`;\n  }\n\n  return `${feedbackSection}## ASSET CONTEXT\n\n**Asset ID:** ${asset.asset_id || 'Unknown'}\n**Sector:** ${nd.sector || asset.sector || 'Unknown'}\n**Asset Type:** ${nd.asset_type || asset.asset_type || 'Unknown'}\n**Country:** ${asset.country || 'Unknown'}\n**Value:** €${(asset.value_eur || 0).toLocaleString()}\n**Analysis Attempt:** ${attemptNumber} of 3\n\n## ENVIRONMENTAL CONTEXT\n\n**Biome:** ${nd.environmental_context?.biome || 'Unknown'}\n**Ecoregion:** ${nd.environmental_context?.ecoregion || 'Unknown'}\n**Water Stress:** ${nd.environmental_context?.water_stress_level || 'Unknown'}\n**Biodiversity Sensitivity:** ${nd.environmental_context?.biodiversity_sensitivity || 'Unknown'}\n\n## TNFD SCENARIO\n\n**Scenario:** ${frame.scenario?.scenario_name || 'Unknown'}\n**Description:** ${frame.scenario_detail?.description || ''}\n**Risk Posture:** ${frame.scenario_detail?.risk_posture || ''}\n**Physical Risk:** ${frame.physical_axis_detail?.interpretation || 'Unknown'}\n**Transition Risk:** ${frame.transition_axis_detail?.interpretation || 'Unknown'}\n**Horizon Year:** ${frame.horizon_year || 2030}\n\n## FINANCIAL CONTEXT\n\n${financialContext}\n\n## EVIDENCE-GROUNDED PATHWAYS (from Evidence Synthesizer)\n\n${evidencePathways || 'No pathways provided.'}\n\n## CRITICAL DEPENDENCIES\n\n${criticalDeps.map(d => `\n- **${d.ecosystem_service}** (${d.dependency_strength})\n  - Type: ${d.dependency_type}\n  - Substitutability: ${d.substitutability}\n  - Time to Failure: ${d.time_to_failure}`).join('\\n')}\n\n---\n\n## SUGGESTED RAG QUERIES FOR STRATEGY GROUNDING\n\n**Use Pinecone to ground your strategies in authoritative guidance.**\n\n${formattedQueries}\n\n---\n\n## YOUR TASK\n\n1. **USE PINECONE** to retrieve strategy guidance before proposing actions\n2. **Ground each strategy** in retrieved evidence (SBTN, TNFD, case studies)\n3. **Cite real cost benchmarks** where found\n4. **Reference actual case studies** with outcomes\n5. **Acknowledge gaps** where no guidance was found\n6. **Sequence actions** across short/medium/long term\n${attemptNumber > 1 ? '7. **Address all evaluator feedback** and note changes in revision_notes' : ''}\n\n### Quality Checklist\n\n☐ Did I search Pinecone for framework guidance?\n☐ Did I search for relevant case studies?\n☐ Did I search for cost benchmarks?\n☐ Is every claim traceable to a source or marked as estimate?\n☐ Did I note gaps where retrieval yielded nothing?\n${attemptNumber > 1 ? '☐ Did I address all critical issues from the evaluator?' : ''}\n\nRespond with valid JSON only.`;\n}\n\n// ============================================================================\n// MAIN EXECUTION\n// ============================================================================\n\nconst userPrompt = buildAdaptationStrategistPrompt($json);\nconst attemptNumber = $json.agent_attempt || $json.loopContext?.attempt_number || 1;\n\nconst nd = $json.nature_dependency || {};\nconst asset = $json.asset || {};\nconst frame = $json.tnfd_scenario_frame || {};\n\nconst strategyQueries = buildStrategyQueries(\n  nd.dependencies,\n  nd.matched_sectors?.[0] || asset.sector || \"manufacturing\",\n  frame.scenario?.scenario_name || \"Unknown\",\n  asset.country || \"Unknown\"\n);\n\nreturn {\n  ...$json,\n  adaptation_strategist_prompt: {\n    system: ADAPTATION_STRATEGIST_SYSTEM_PROMPT,\n    user: userPrompt\n  },\n  strategy_rag_queries: strategyQueries,\n  current_agent: \"adaptation_strategist\",\n  current_attempt: attemptNumber\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        9808,
        1328
      ],
      "id": "6ef781a5-c910-4c13-a0cc-13a2be6a9b8b",
      "name": "Build Adaptation Strategist Prompt"
    }
  ],
  "pinData": {},
  "connections": {
    "Normalize JSON": {
      "main": [
        [
          {
            "node": "Gov: Init run metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Portfolio": {
      "main": [
        [
          {
            "node": "Gov: Build issues register",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Explode Valid Assets": {
      "main": [
        [
          {
            "node": "Cache Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ClimateData": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Cache Write",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GBIF-IUCN": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Biome": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Flood": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ClimateTRACE": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Gov: Init run metadata": {
      "main": [
        [
          {
            "node": "Gov: Rules catalog",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gov: Build issues register": {
      "main": [
        [
          {
            "node": "Gov: Score DQ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gov: Rules catalog": {
      "main": [
        [
          {
            "node": "Validate Portfolio",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gov: Score DQ": {
      "main": [
        [
          {
            "node": "Split Issues",
            "type": "main",
            "index": 0
          },
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Issues": {
      "main": [
        [
          {
            "node": "Manual handling",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Manual handling": {
      "main": [
        [
          {
            "node": "Append or update row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "Explode Valid Assets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize JSON2": {
      "main": [
        [
          {
            "node": "Initialize loop context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NF Loop: Dependency Mapper": {
      "main": [
        [
          {
            "node": "Clean API data(optional)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pinecone Vector Store1": {
      "ai_tool": [
        [
          {
            "node": "Evidence Synthesizer",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "Pinecone Vector Store1",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Evidence Synthesizer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "NF Loop: TNFD Axes + Scenario Pick": {
      "main": [
        [
          {
            "node": "NF Loop- Shock Grid",
            "type": "main",
            "index": 0
          },
          {
            "node": "Query builder for RAG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Query builder for RAG": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Initialize loop context": {
      "main": [
        [
          {
            "node": "NF Loop: Dependency Mapper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Evidence Synthesizer": {
      "main": [
        [
          {
            "node": "Parse Evidence Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Evidence Output": {
      "main": [
        [
          {
            "node": "Build Adaptation Strategist Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Strategy Output": {
      "main": [
        [
          {
            "node": "Build Narrative Intelligence Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Narrative Intelligence Prompt": {
      "main": [
        [
          {
            "node": "Narrative Intelligence",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "Narrative Intelligence",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Narrative Intelligence": {
      "main": [
        [
          {
            "node": "Parse Narrative Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "initialise counter": {
      "main": [
        [
          {
            "node": "Build Evidence Synthesizer Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Narrative Output": {
      "main": [
        [
          {
            "node": "Build Evaluator Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Evaluator Prompt": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model4": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "Parse Evaluation Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Evaluation Output": {
      "main": [
        [
          {
            "node": "Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NF Loop: Financial Impact Engine": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "NF Loop- Shock Grid": {
      "main": [
        [
          {
            "node": "NF Loop: Financial Impact Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "initialise counter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Test Case Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Test Case Generator": {
      "main": [
        [
          {
            "node": "Normalize JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cache Check": {
      "main": [
        [
          {
            "node": "Get row(s) in sheet",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge2",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get row(s) in sheet": {
      "main": [
        [
          {
            "node": "Merge2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Cache Result": {
      "main": [
        [
          {
            "node": "If3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If3": {
      "main": [
        [
          {
            "node": "Normalize JSON2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Flood",
            "type": "main",
            "index": 0
          },
          {
            "node": "Biome",
            "type": "main",
            "index": 0
          },
          {
            "node": "GBIF-IUCN",
            "type": "main",
            "index": 0
          },
          {
            "node": "ClimateData",
            "type": "main",
            "index": 0
          },
          {
            "node": "ClimateTRACE",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Cache Write": {
      "main": [
        [
          {
            "node": "Append or update row in sheet1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Normalize JSON2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge2": {
      "main": [
        [
          {
            "node": "Process Cache Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean API data(optional)": {
      "main": [
        [
          {
            "node": "NF Loop: TNFD Axes + Scenario Pick",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pinecone Vector Store": {
      "ai_tool": [
        [
          {
            "node": "Adaptation strategist",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI1": {
      "ai_embedding": [
        [
          {
            "node": "Pinecone Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "Adaptation strategist",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Adaptation strategist": {
      "main": [
        [
          {
            "node": "Parse Strategy Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Evidence Synthesizer Prompt": {
      "main": [
        [
          {
            "node": "Evidence Synthesizer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Adaptation Strategist Prompt": {
      "main": [
        [
          {
            "node": "Adaptation strategist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  }
}  